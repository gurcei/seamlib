#output "seamlib"


'--------
.declares
'--------
#declare fidx, frame_count, anim_count
#declare bkp_d054&, bkp_d058&, bkp_d059&, bkp_d05e&
#declare my_err$, k, idx, x, y, value
#declare chr_width(100), chr_height(100), char_idx(100)
#declare objx, objy, oldyy, minyy, maxyy, yybot 
#declare a$, yy, offsy


'-------
.defines
'-------
#define KEY_ESCAPE = chr$(27)
#define KEY_UP = "{x91}"
#define KEY_DOWN = "{x11}"
#define KEY_LEFT = "{x9D}"
#define KEY_RIGHT = "{x1D}"
#define KEY_MEGA_Q = "«"

#define WIDTH = 200

#define INVALID = -666

trap runstop_trapper

'----
.main
'----
  gosub init

  fidx = 0
  gosub stage_object

  gosub user_input

  end



'----
.init
'----
  bank 128
  key off

  ' hard-coding a few values that will be variable in future
  fidx = 0
  chr_width(0) = 3
  chr_height(0) = 3
  char_idx(0) = $1008
  frame_count = 1
  anim_count = 0

  oldyy = INVALID

  print "{x93}";KEY_ESCAPE;"5";
  
  bkp_d054& = peek($d054)
  bkp_d058& = peek($d058)
  bkp_d059& = peek($d059)
  bkp_d05e& = peek($d05e)

  ' set SEAM mode CHR16 + FCLRHI
  setbit $d054, 0
  setbit $d054, 2

  wpoke $d058, WIDTH
  poke $d05e, WIDTH / 2

  poke $d021, 14
  poke $d020, 0

  ' $1000 = solid fcm char
  for k = 0 to 63
    poke $40000 + k, $ff
  next k

  ' $1001 = box char
  for k = 0 to 63
    if int(k / 8) = 0 or int(k / 8) = 7 then poke $40040 + k, $ff:goto nxt
    if mod(k, 8) = 0 or mod(k, 8) = 7 then poke $40040 + k, $ff:goto nxt
    poke $40040 + k, $00
.nxt
  next k

  ' $1002 = tl box
  idx = 0
  for y = 0 to 7
    for x = 0 to 7
    value = $ff
    if y = 0 then value = $01
    if x = 0 then value = $01
    if y = 7 and x = 7 then value = $01
    poke $40080 + idx, value
    idx = idx + 1
    next x
  next y

  ' $1003 = t box
  idx = 0
  for y = 0 to 7
    for x = 0 to 7
      value = $ff
      if y = 0 then value = $01
      if y = 7 and x = 7 then value = $01
      poke $400c0 + idx, value
      idx = idx + 1
    next x
  next y

  ' $1004 = l box
  idx = 0
  for y = 0 to 7
    for x = 0 to 7
      value = $ff
      if x = 0 then value = $01
      if y = 7 and x = 7 then value = $01
      poke $40100 + idx, value
      idx = idx + 1
    next x
  next y

  ' $1005 = m box
  idx = 0
  for y = 0 to 7
    for x = 0 to 7
      value = $ff
      if y = 7 and x = 7 then value = $01
      poke $40140 + idx, value
      idx = idx + 1
    next x
  next y

  ' $1006 = l line
  idx = 0
  for y = 0 to 7
    for x = 0 to 7
      value = $00
      if x = 0 then value = $01
      poke $40180 + idx, value
      idx = idx + 1
    next x
  next y

  ' $1007 = t line
  idx = 0
  for y = 0 to 7
    for x = 0 to 7
      value = $00
      if y = 0 then value = $01
      poke $401c0 + idx, value
      idx = idx + 1
    next x
  next y


  return


'---------------
.runstop_trapper
'---------------
  ' if er<>30 then resume  ' ignore everything except run/stop

  my_err$ = "?" + err$(er) + " in line " + str$(el)

.cleanup
  print "{x93}";my_err$
  trap
  poke $d054, bkp_d054&
  poke $d058, bkp_d058&
  poke $d059, bkp_d059&
  poke $d05e, bkp_d05e&

  end


'------------
.stage_object
'------------
  for y = 0 to 49
    ' prepare initial gotox char
    poke $ff80000 + y * WIDTH + 160, %10010000
    wpoke $40800 + y * WIDTH + 160, 80 * 8  ' keep off-screen initially

    ' prepare ending gotox char
    poke $ff80000 + y * WIDTH + 160 + (chr_width(fidx) + 1) * 2, %10010000
    wpoke $40800 + y * WIDTH + 160 + (chr_width(fidx) + 1) * 2, 80 * 8
  next y

  gosub draw_object

  return


'----------
.user_input
'----------
  do while 1
    gosub draw_object

    get key a$
    if a$ = KEY_LEFT then gosub handle_left
    if a$ = KEY_RIGHT then gosub handle_right
    if a$ = KEY_UP then gosub handle_up
    if a$ = KEY_DOWN then gosub handle_down
    if a$ = KEY_MEGA_Q then goto cleanup
  loop
  return


.draw_object
'-----------
  yy = int(objy / 8)
  yybot = yy + chr_height(fidx) ' - 1
  offsy = mod(objy, 8)

  ' clear prior position (if needbe)
  if oldyy <> INVALID and yy <> oldyy then begin
    minyy = oldyy
    maxyy = oldyy + chr_height(fidx) ' - 1
    if minyy < yy and yy < maxyy then maxyy = yy - 1
    if minyy < yybot and yybot < maxyy then minyy = yybot + 1

    ' hide these rows off-screen
    for y = minyy to maxyy
      wpoke $40800 + y * WIDTH + 160, 80 * 8 
    next y
  bend

  ' draw chars on desired yrows, and at right objx position
  idx = char_idx(fidx)
  for x = 0 to chr_width(fidx) - 1
    for y = 0 to chr_height(fidx) - 1
      wpoke $40800 + (yy + y) * WIDTH + 162 + x * 2, idx

      ' copy last y-line an extra line below (to help with y scrolling)
      if y = chr_height(fidx) - 1 then begin
        wpoke $40800 + (yy + y + 1) * WIDTH + 162 + x * 2, idx
      bend

      idx = idx + 1
    next y
  next x

  ' handle negative x
  x = objx
  if objx < 0 then x = 1024 + objx

  k = x + (offsy * 32 + 16) * 256

  ' set initial rowmask
  poke $ff80000 + yy * WIDTH + 160, %10011000
  poke $ff80000 + yy * WIDTH + 160 + 1, 255 << offsy and 255


  ' set initial gotox char
  for y = yy to yy + chr_height(fidx) - 1
    if y <> yy then begin
      poke $ff80000 + y * WIDTH + 160, %10010000
    bend
    wpoke $40800 + y * WIDTH + 160, k
  next y

  ' set final yoffs
  k = x + ( ((8-offsy) and 7) * 32) * 256
  wpoke $40800 + yybot * WIDTH + 160, k

  ' set final rowmask
  poke $ff80000 + yybot * WIDTH + 160, %10011000
  poke $ff80000 + yybot * WIDTH + 160 + 1, 255 >> (8 - offsy) and 255


  oldyy = yy
  return


'-----------
.handle_left
'-----------
  objx = objx - 1
  return


'------------
.handle_right
'------------
  objx = objx + 1
  return


'---------
.handle_up
'---------
  objy = objy - 1
  return


'-----------
.handle_down
'-----------
  objy = objy + 1
  return
ÿ