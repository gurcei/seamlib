#output "seamlib"

#define SPR_MAX = 13 - 1

clr

'--------
.declares
'--------
#declare fidx, frame_count%, anim_count
#declare bkp_d054&, bkp_d058&, bkp_d059&, bkp_d05e&
#declare my_err$, k, idx, x, y, value

' frame details
#declare default_slice(100), char_type(100), char_idx%(100)
#declare chr_width%(100), chr_height%(100)
#declare bb_tlx&(100,10), bb_tly&(100,10), bb_brx&(100,10), bb_bry&(100,10)
#declare bb_cnt&(100)
#declare old_fidx

' sprite details
#declare spr_chr_width%(100), spr_chr_height%(100), spr_char_idx%(100)
#declare spr_frame_count%(100), spr_frames&(100,20), spr_visible%(100)
#declare spr_fidx&(100), stage_x_offs%(100), spr_count
#declare spr_ox%(100), spr_oy%(100)
#declare spr_collide&(SPR_MAX ,SPR_MAX)
#declare objx, objy, oldyy, minyy, maxyy, yybot 
#declare a$, yy, offsy, tmp, tmpx, tmpy
#declare tclr, tx, ty, rev_flag, chr
#declare ln$, char_count, xx, kk, sidx, old_sidx, anim_tmr
#declare cx, cy, sidx2, objx2, objy2, k1, k2
#declare box1_x1%, box1_y1%, box1_x2%, box1_y2%
#declare box2_x1%, box2_y1%, box2_x2%, box2_y2%
#declare collision_flag, fidx2
#declare aptr_lo, aptr_hi, score, health, radius

#declare wolf_x(3), wolf_y(3), wolf_vx(3), wolf_vy(3), dx, dy

#declare pane_x%, pane_y%, pane_width%, pane_height%
#declare game_over_flag

#declare cycle_start, colour_cycle_flag
#declare default_red&(32), default_green&(32), default_blue&(32)
#declare girl_vx, girl_vy, wolf_die(3), key_flag

#declare gem_x(2), gem_y(2), gem_vx(2), gem_vy(2), chest_time
#declare widx, wolf_cnt, bkp_d051&, v, b$, jval

#declare title_chr_width%(10), title_chr_height%(10), title_char_idx%(10)
#declare title_ox%(10), title_oy%(10), title_stage_x_offs%(10)
#declare title_count, dr

#declare snd_idx, snd_order(5), gx, water, iter, wolf_speed
#declare carpet_time, hs_name$(3), hs_score(3)

#declare debug_bb = 0

.music_vars
'----------
#define chunk_max = 50
#declare chunk_cnt, chunk_idx, vidx, tmpo%, row
#declare echo_m, echo_b, echo_sz = .05, chunk_rpt, echo_delay
#declare v$(5,chunk_max), v
#declare song$
#declare v1$, v2$, v3$, v4$, v5$, v6$
#declare curr_freq, curr_dir

#declare seqcnt
#declare seq_chunk(200), seq_extra(200)

#declare plyptr, plyflag, ret%, tmp$, playidx%

#declare attack, decay, sustain, release, waveform, pw

#declare initial_run, end_time


'-------
.defines
'-------
#define KEY_ESCAPE = chr$(27)
#define KEY_REV_ON = "{x12}"
#define KEY_REV_OFF = "{x92}"
#define KEY_UP = "{x91}"
#define KEY_DOWN = "{x11}"
#define KEY_LEFT = "{x9D}"
#define KEY_RIGHT = "{x1D}"
#define KEY_MEGA_Q = "«"

#define WIDTH = 270

#define OP_COPY = 0
#define OP_MIX  = 1
#define OP_SWAP = 2
#define OP_FILL = 3


#define INVALID = -666

' seam frames
#define F_CARPET = 0
#define F_WOLF1 = 1
#define F_KEY = 2
#define F_BANANA = 3
#define F_WBOTTLE = 4
#define F_WOLF2 = 5
#define F_GIRL1 = 6
#define F_GIRL2 = 7
#define F_CHEST2 = 8
#define F_CHEST1 = 9
#define F_GEM1 = 10
#define F_GEM2 = 11
#define F_GEM3 = 12
#define F_CHAR_S = 13
#define F_CHAR_P = 14
#define F_CHAR_R = 15
#define F_CHAR_I = 16
#define F_CHAR_N = 17
#define F_CHAR_G = 18


' seam sprites
#define S_CARPET = 0
#define S_BANANA = 1
#define S_WBOTTLE = 2
#define S_CHEST = 3
#define S_KEY = 4
#define S_GEM1 = 5
#define S_GEM2 = 6
#define S_GEM3 = 7
#define S_WOLF1 = 8
#define S_WOLF2 = 9
#define S_WOLF3 = 10
#define S_WOLF4 = 11
#define S_GIRL = 12

' seam title sprites
#define S_CHAR_S = 0
#define S_CHAR_P = 1
#define S_CHAR_R = 2
#define S_CHAR_I = 3
#define S_CHAR_N = 4
#define S_CHAR_G = 5

#define CMD_LOOP = -3

spr_count = SPR_MAX + 1
title_count = 6

trap runstop_trapper

'----
.main
'----
  gosub init


  do while 1
    gosub title_screen

    gosub main_game
  loop

  end


'--------------------
.parse_current_seqptr
'--------------------
  ret% = 0
  if plyptr = -1 then ret%=1:return
  if rplay(1)<>0 then ret%=1:return

  k = seq_chunk(plyptr)
  
  if k >= 0 then begin
    chunk_idx = k
    if chunk_rpt <= 0 then chunk_rpt = seq_extra(plyptr)
    gosub play_chunk_idx
    playidx% = playidx% + 1
    ret% = 1
  bend

  plyptr = plyptr + 1

  if k = CMD_LOOP then plyptr = 0

  if plyptr >= seqcnt then plyflag = 0 : plyptr = -1
  return


'--------------
.play_chunk_idx
'--------------
  play v$(0, chunk_idx), v$(1, chunk_idx), v$(2, chunk_idx), {x5F}
       v$(3, chunk_idx), v$(4, chunk_idx), v$(5, chunk_idx)
  return


'-----
.boing
'-----
  sound snd_order(snd_idx), 20000, 10, 0, 100, 1000, 1
  snd_idx = mod(snd_idx + 1, 6)
  return


'------------------
.stage_game_objects
'------------------
  gosub prepare_interface_vars_for_game

  for sidx = 0 to spr_count - 1
    gosub stage_object
    gosub parse_current_seqptr
  next sidx

  sidx = 0
  return


'-------------------
.stage_title_objects
'-------------------
  gosub prepare_interface_vars_for_title

  for sidx = 0 to title_count - 1
    gosub stage_title_object
    if initial_run = 0 then gosub parse_current_seqptr
  next sidx

  initial_run = 0
  sidx = 0
  return


'------------
.title_screen
'------------
  gosub clrscreen

  gosub stage_title_objects

  vol 10, 10

  tclr = 0 : tx = 0 : ty = 12

  a$ = "A game made by Moana (and her daddy) in 2025"
  gosub draw_text_centred

  ty = ty + 2 : a$ = "Made using Eleven + BASIC 65 + 'SEAMLIB' library."
  gosub draw_text_centred

  tclr = 14 + $40
  ty = ty + 3 : a$ = "Joystick port 2"
  gosub draw_text_centred

  tclr = 0 + $80  ' $80 = underline
  ty = ty + 3 : a$ = "Choose level of difficulty:"
  gosub draw_text_centred

  ty = ty + 2
  tmp = ty
  a$ = KEY_REV_ON + "                     "

  for k = 0 to 10
    tclr = 0
    tx = 29
    gosub draw_text

    tx = 80
    gx = 29 * 8
    gosub draw_gotox_char

    tx = 102
    gx = 640
    gosub draw_gotox_char

    ty = ty +1
  next k

  tclr = 10 + $40
  tx = 81
  ty = tmp + 1
  a$ = "  (1) Easy"
  gosub draw_text

  tclr = 6 + $40
  ty = ty + 2 : a$ = "  (2) Medium"
  gosub draw_text

  tclr = 3 + $40
  ty = ty + 2 : a$ = "  (3) Difficult"
  gosub draw_text

  tclr = 0 + $40
  ty = ty + 2 : a$ = "  (4) Extreme"
  gosub draw_text

  tclr = 13 + $40
  ty = ty + 2 : a$ = "  (X) Exit to BASIC"
  gosub draw_text

  tclr = 0 + $80  ' $80 = underline
  tx = 7
  ty = ty + 2 : a$ = "Instructions:"
  gosub draw_text

  tclr = 0
  ty = ty + 2
  a$ = "- Navigate your cute hero, Spring, to avoid the baddie wolves"
  gosub draw_text

  ty = ty + 1
  a$ = "- Use key to unlock the chest to collect gems"
  gosub draw_text

  ty = ty + 1
  a$ = "- Eat bananas to keep your health up"
  gosub draw_text

  ty = ty + 1
  a$ = "- Drink water to prevent dehydration"
  gosub draw_text

  ty = ty + 1
  a$ = "- Use magic carpet to fly around faster and kill baddies"
  gosub draw_text

  ty = ty + 3
  tx = 2
  a$ = "- The song is Gurce's cover of the 'Dungeon of the Algebra Dragons' theme"
  gosub draw_text

  ty = ty + 2
  a$ = "- Consider supporting Moana and her daddy's games with a donation here:"
  gosub draw_text

  ty = ty + 2
  tclr = 3
  a$ = "  - https://paypal.me/gurcei"
  gosub draw_text

  ty = ty + 2
  a$ = "  - https://patreon.com/gurce"
  gosub draw_text

  tclr = 0

  k = fre(1)  ' garbage collect


  tx = 50
  dr = 2

  do while 1
    get a$

    if a$ = "1" then wolf_cnt = 0 : exit
    if a$ = "2" then wolf_cnt = 1 : exit
    if a$ = "3" then wolf_cnt = 2 : exit
    if a$ = "4" then wolf_cnt = 3 : exit
    if a$ = "x" or a$ = KEY_MEGA_Q then goto cleanup

    gosub animate_title

    gosub parse_current_seqptr
  loop

  gosub clrscreen

  gosub restore_default_colours

  return


'-------------
.animate_title
'-------------
  for k = 0 to title_count - 1
    title_ox%(S_CHAR_S + k) = tx + k * 45
    title_oy%(S_CHAR_S + k) = 40 - 30 * abs(sin(2 * ti + k * .6))
  next k
  tx = tx + dr
  if tx > 360 then dr = -dr : tx = 360
  if tx < 10 then dr = -dr : tx = 10

  gosub draw_objects

  gosub cycle_colours

  return

'-------------------------------
.prepare_interface_vars_for_game
'-------------------------------
  ' prepare interface vars for assembly
  bank 0
  wpoke $7e00, pointer(spr_ox%(0))
  wpoke $7e02, pointer(spr_oy%(0))
  wpoke $7e04, pointer(spr_chr_width%(0))
  wpoke $7e06, pointer(spr_chr_height%(0))
  wpoke $7e08, pointer(spr_char_idx%(0))
  wpoke $7e0a, pointer(stage_x_offs%(0))
  poke $7e0c, spr_count

  wpoke $7e1a, pointer(spr_fidx&(0))
  wpoke $7e1c, pointer(spr_frames&(0,0))
  wpoke $7e1e, pointer(bb_cnt&(0))
  wpoke $7e20, pointer(bb_tlx&(0,0))
  wpoke $7e22, pointer(bb_tly&(0,0))
  wpoke $7e24, pointer(bb_brx&(0,0))
  wpoke $7e26, pointer(bb_bry&(0,0))
  wpoke $7e28, pointer(spr_collide&(0,0))
  bank 128
  return


'--------------------------------
.prepare_interface_vars_for_title
'--------------------------------
  bank 0
  wpoke $7e00, pointer(title_ox%(0))
  wpoke $7e02, pointer(title_oy%(0))
  wpoke $7e04, pointer(title_chr_width%(0))
  wpoke $7e06, pointer(title_chr_height%(0))
  wpoke $7e08, pointer(title_char_idx%(0))
  wpoke $7e0a, pointer(title_stage_x_offs%(0))
  poke $7e0c, title_count
  bank 128

  return


'------------------------
.load_current_high_scores
'------------------------
  dopen #2, "scores", r, u8

  for k = 0 to 3
    input #2, hs_name$(k)
    input #2, hs_score(k)
  next k

  dclose #2
  return


'----
.init
'----
  print chr$(14);  ' lower-case
  print "Loading game..."

  bank 0
  bload "game.pal",p($ffd3100)
  bload "chars.bin",p($40000),r
  ln$ = "moana4.bin"
  gosub load_data
  bload "asmhelper"
  bank 128
  key off

  gosub load_current_high_scores

  initial_run = 1

  song$ = "dragon.p"
  gosub load_song

  gosub store_default_colours

  aptr_lo = pointer(a$) and $ff
  aptr_hi = pointer(a$) / 256

  ' prepare title details
  for k = 0 to title_count - 1
    title_chr_width%(S_CHAR_S + k) = 5
    title_chr_height%(S_CHAR_S + k) = 5
    title_char_idx%(S_CHAR_S + k) = char_idx%(F_CHAR_S + k)
  next k

  ' prepare sprite details
  spr_chr_width%(S_CARPET) = 3
  spr_chr_height%(S_CARPET) = 3
  spr_char_idx%(S_CARPET) = char_idx%(F_CARPET)
  spr_frame_count%(S_CARPET) = 1
  spr_frames&(S_CARPET, 0) = F_CARPET

  spr_chr_width%(S_KEY) = 1
  spr_chr_height%(S_KEY) = 1
  spr_char_idx%(S_KEY) = char_idx%(F_KEY)
  spr_frame_count%(S_KEY) = 1
  spr_frames&(S_KEY, 0) = F_KEY

  spr_chr_width%(S_BANANA) = 2
  spr_chr_height%(S_BANANA) = 2
  spr_char_idx%(S_BANANA) = char_idx%(F_BANANA)
  spr_frame_count%(S_BANANA) = 1
  spr_frames&(S_BANANA, 0) = F_BANANA

  spr_chr_width%(S_WBOTTLE) = 3
  spr_chr_height%(S_WBOTTLE) = 3
  spr_char_idx%(S_WBOTTLE) = char_idx%(F_WBOTTLE)
  spr_frame_count%(S_WBOTTLE) = 1
  spr_frames&(S_WBOTTLE, 0) = F_WBOTTLE

#define WOLF_MAX = 3

  for k = 0 to WOLF_MAX
    spr_chr_width%(S_WOLF1 + k) = 4
    spr_chr_height%(S_WOLF1 + k) = 4
    spr_char_idx%(S_WOLF1 + k) = char_idx%(F_WOLF1)
    spr_frame_count%(S_WOLF1 + k) = 2
    spr_frames&(S_WOLF1 + k, 0) = F_WOLF1
    spr_frames&(S_WOLF1 + k, 1) = F_WOLF2
  next k

  spr_chr_width%(S_GIRL) = 4
  spr_chr_height%(S_GIRL) = 4
  spr_char_idx%(S_GIRL) = char_idx%(F_GIRL1)
  spr_frame_count%(S_GIRL) = 2
  spr_frames&(S_GIRL, 0) = F_GIRL1
  spr_frames&(S_GIRL, 1) = F_GIRL2

  spr_chr_width%(S_CHEST) = 4
  spr_chr_height%(S_CHEST) = 4
  spr_char_idx%(S_CHEST) = char_idx%(F_CHEST1)
  spr_frame_count%(S_CHEST) = 2
  spr_frames&(S_CHEST, 0) = F_CHEST1
  spr_frames&(S_CHEST, 1) = F_CHEST2

  spr_chr_width%(S_GEM1) = 2
  spr_chr_height%(S_GEM1) = 2
  spr_char_idx%(S_GEM1) = char_idx%(F_GEM1)
  spr_frame_count%(S_GEM1) = 1
  spr_frames&(S_GEM1, 0) = F_GEM1

  spr_chr_width%(S_GEM2) = 2
  spr_chr_height%(S_GEM2) = 2
  spr_char_idx%(S_GEM2) = char_idx%(F_GEM2)
  spr_frame_count%(S_GEM2) = 1
  spr_frames&(S_GEM2, 0) = F_GEM2

  spr_chr_width%(S_GEM3) = 2
  spr_chr_height%(S_GEM3) = 2
  spr_char_idx%(S_GEM3) = char_idx%(F_GEM3)
  spr_frame_count%(S_GEM3) = 1
  spr_frames&(S_GEM3, 0) = F_GEM3

    
  ' keep all sprites off-screen to start with
  ' that's my simple workaround for now to make them 'invisible'
  for k = 0 to spr_count - 1
    spr_ox%(k) = 640
    spr_oy%(k) = 10 * 8
  next k

  ' hard-coding a few values that will be variable in future
  fidx = 0

  oldyy = INVALID

  print "{x93}";KEY_ESCAPE;"5";

  bkp_d051& = peek($d051)  
  bkp_d054& = peek($d054)
  bkp_d058& = peek($d058)
  bkp_d059& = peek($d059)
  bkp_d05e& = peek($d05e)

  ' clear NORRDEL: when clear, double-buffering is used
  clrbit $d051, 7

  ' set SEAM mode CHR16 + FCLRHI
  setbit $d054, 0
  setbit $d054, 2

  wpoke $d058, WIDTH
  poke $d05e, WIDTH / 2

  poke $d021, 14
  poke $d020, 0

  snd_order(0) = 1
  snd_order(1) = 4
  snd_order(2) = 2
  snd_order(3) = 5
  snd_order(4) = 3
  snd_order(5) = 6
  return


'---------------
.runstop_trapper
'---------------
  ' if er<>30 then resume  ' ignore everything except run/stop

  my_err$ = "?" + err$(er) + " in line " + str$(el)

.cleanup
  print "{x93}";my_err$
  trap

  gosub do_cleanup

  end


'----------
.do_cleanup
'----------
  bank 128
  poke $d051, bkp_d051&
  poke $d054, bkp_d054&
  poke $d058, bkp_d058&
  poke $d059, bkp_d059&
  poke $d05e, bkp_d05e&

  key on

  play
  return


'---------
.clrscreen
'---------
  bank 0
  sys $7f06
  bank 128

  return


'------------
.stage_object
'------------
  if sidx > 0 then begin
    stage_x_offs%(sidx) = stage_x_offs%(sidx-1) + spr_chr_width%(sidx-1) + 1
  bend

  for y = 0 to 49
    ' prepare initial gotox char
    poke $ff80000 + y * WIDTH + 160 + stage_x_offs%(sidx) * 2, %10010000
    wpoke $40800 + y * WIDTH + 160 + stage_x_offs%(sidx) * 2, 80 * 8  ' keep off-screen initially

    ' prepare ending gotox char
    poke $ff80000 + y * WIDTH + 160 + stage_x_offs%(sidx) * 2 + (spr_chr_width%(sidx) + 1) * 2, %10010000
    wpoke $40800 + y * WIDTH + 160 + stage_x_offs%(sidx) * 2 + (spr_chr_width%(sidx) + 1) * 2, 80 * 8
  next y

  return


'---------------
.draw_gotox_char
'---------------
  ' prepare initial gotox char
  poke $ff80000 + ty * WIDTH + tx * 2, %10010000
  wpoke $40800 + ty * WIDTH + tx * 2, gx

  return


'------------------
.stage_title_object
'------------------
  if sidx > 0 then begin
    title_stage_x_offs%(sidx) = {x5F}
      title_stage_x_offs%(sidx-1) + title_chr_width%(sidx-1) + 1
  bend

  for y = 0 to 15
    ' prepare initial gotox char
    poke $ff80000 + y * WIDTH + 160 + title_stage_x_offs%(sidx) * 2, %10010000
    wpoke $40800 + y * WIDTH + 160 + title_stage_x_offs%(sidx) * 2, 80 * 8  ' keep off-screen initially

    ' prepare ending gotox char
    poke $ff80000 + y * WIDTH + 160 + title_stage_x_offs%(sidx) * 2 + (title_chr_width%(sidx) + 1) * 2, %10010000
    wpoke $40800 + y * WIDTH + 160 + title_stage_x_offs%(sidx) * 2 + (title_chr_width%(sidx) + 1) * 2, 80 * 8
  next y

  return


'-------------
.check_hiscore
'-------------
  if score >= hs_score(wolf_cnt) then begin
    bank 0 : poke $1600, asc("h"), asc("s")
    poke $1602, wolf_cnt  ' level index
    a$ = str$(score)
    for k = 0 to len(a$)-1
      poke $1603 + k, asc(mid$(a$,k+1,1))
    next k
    poke $1603 + len(a$), 0

    gosub clrscreen
    gosub do_cleanup
    dload "hiscore"
  bend

  return

'---------
.main_game
'---------
  gosub stage_game_objects

  score = 0 : health = 10 : water = 20
  gosub draw_score
  gosub draw_hiscore
  gosub draw_energy_bars

  ' lower music volume, but raise sound effect volume
  vol 5, 5
  ' for music
  poke $ffd3458, $7  ' SID3 @ $D440
  poke $ffd3418, $7  ' SID1 @ $D400
  ' for sound
  poke $ffd3478, $f  ' SID4 @ $D460
  poke $ffd3438, $f  ' SID2 @ $D420


  gosub init_level

  k = fre(1)  ' do garbage collection after any string work

  do while game_over_flag = 0
    ' gosub draw_coords

    gosub user_input

    gosub baddie_logic

    gosub draw_objects

    gosub animate_objects

    gosub check_box_collisions

    gosub game_logic

    gosub parse_current_seqptr
  loop

  gosub check_hiscore

  return


'----------
.game_logic
'----------
  for widx = 0 to wolf_cnt
    if spr_collide&(S_GIRL, S_WOLF1 + widx) <> 0 then gosub handle_wolf_collision
  next widx

  if spr_collide&(S_GIRL, S_KEY) <> 0 then gosub handle_key_collision

  if spr_collide&(S_GIRL, S_BANANA) <> 0 then gosub handle_banana_collision

  if spr_collide&(S_GIRL, S_WBOTTLE) <> 0 then gosub handle_wbottle_collision

  if spr_collide&(S_GIRL, S_CARPET) <> 0 then gosub handle_carpet_collision

  if spr_collide&(S_GIRL, S_CHEST) <> 0 then gosub handle_chest_collision

  if colour_cycle_flag = 1 then gosub handle_colour_cycling

  if key_flag >= 2 then gosub handle_chest_visibility

  if mod(iter, 25) = 0 then gosub handle_water_drop
  iter = iter + 1

  return


'-----------------
.handle_water_drop
'-----------------
  water = water - 1
  gosub draw_energy_bars
  if water = 0 then begin
    colour_cycle_flag = 0
    gosub restore_default_colours

    gosub clrscreen

    tclr = 2 : a$ = "You died of dehydration!"
    pane_width% = len(a$) + 4
    pane_height% = 5
    gosub show_centred_pane

    ' sleep two secs with music polling
    end_time = ti
    do while (ti - end_time) < 2
      gosub parse_current_seqptr
    loop

    ' clear keyboard buffer
    for k = 0 to 16
      get a$
    next k
            
    game_over_flag = 1
  bend
  return


'-----------------------
.handle_chest_visibility
'-----------------------
  if (ti - chest_time) > 5 and spr_ox%(S_CHEST) <> 640 then begin
    spr_ox%(S_CHEST) = 640

    spr_fidx&(S_CHEST) = 0
    tmp = char_idx%(spr_frames&(S_CHEST, 0))
    spr_char_idx%(S_CHEST) = tmp

  bend

  if gem_x(0) = 640 and gem_x(1) = 640 and gem_x(2) = 640 then begin
    key_flag = 0
    sidx = S_KEY
    gosub spawn_item

    spr_fidx&(S_CHEST) = 0
    tmp = char_idx%(spr_frames&(S_CHEST, 0))
    spr_char_idx%(S_CHEST) = tmp

    sidx = S_CHEST
    gosub spawn_item
    return
  bend
  
  ' animate gems
  if key_flag < 50 then begin
    key_flag = key_flag + 1
    for k = 0 to 2
      if gem_x(k) <> 640 then begin
        gem_x(k) = gem_x(k) + gem_vx(k)
        if gem_x(k) < 1 then gem_x(k) = 1 : gosub boing : gem_vx(k) = -gem_vx(k)
        if gem_x(k) > 623 then gem_x(k) = 623 : gosub boing : gem_vx(k) = -gem_vx(k)

        gem_y(k) = gem_y(k) + gem_vy(k)
        if gem_y(k) < 16 then gem_y(k) = 16 : gosub boing : gem_vy(k) = -gem_vy(k)
        if gem_y(k) > 383 then gem_y(k) = 383 : gosub boing : gem_vy(k) = -gem_vy(k)

        spr_ox%(S_GEM1 + k) = gem_x(k)
        spr_oy%(S_GEM1 + k) = gem_y(k)

        gem_vx(k) = .97 * gem_vx(k)
        gem_vy(k) = .97 * gem_vy(k)
      bend
    next k
  bend

  if key_flag > 15 then begin
    if spr_collide&(S_GIRL, S_GEM1) then begin
      gem_x(0) = 640 : spr_ox%(S_GEM1) = 640
      score = score + 2000
      gosub draw_score
      k = fre(1)
      sound snd_order(snd_idx), 14000, 5, 0, 8000, 800, 2
      snd_idx = mod(snd_idx + 1, 6)
    bend

    if spr_collide&(S_GIRL, S_GEM2) then begin
      gem_x(1) = 640 : spr_ox%(S_GEM2) = 640
      score = score + 2000
      gosub draw_score
      k = fre(1)
      sound snd_order(snd_idx), 14000, 5, 0, 8000, 800, 2
      snd_idx = mod(snd_idx + 1, 6)
    bend

    if spr_collide&(S_GIRL, S_GEM3) then begin
      gem_x(2) = 640 : spr_ox%(S_GEM3) = 640
      score = score + 2000
      gosub draw_score
      k = fre(1)
      sound snd_order(snd_idx), 14000, 5, 0, 8000, 800, 2
      snd_idx = mod(snd_idx + 1, 6)
    bend

  bend

  return


'----------------------
.handle_chest_collision
'----------------------
  if key_flag = 1 then begin

    sound snd_order(snd_idx), 5000, 10, 02, 3000, 500, 1
    snd_idx = mod(snd_idx + 1, 6)


    key_flag = 2

    chest_time = ti

    spr_fidx&(S_CHEST) = 1
    tmp = char_idx%(spr_frames&(S_CHEST, 1))
    spr_char_idx%(S_CHEST) = tmp

    for k = 0 to 2
      tmp = rnd(1) * 3.14159 + 3.14159
      gem_vx(k) = 5 * cos(tmp)
      gem_vy(k) = 5 * sin(tmp)

      gem_x(k) = spr_ox%(S_CHEST) + 5 * (k + 1)
      gem_y(k) = spr_oy%(S_CHEST)
      spr_ox%(S_GEM1 + k) = gem_x(k)
      spr_oy%(S_GEM1 + k) = gem_y(k)
    next k

  bend

  return


'---------------------
.handle_colour_cycling
'---------------------
  gosub cycle_colours

  if (ti - cycle_start) > carpet_time then begin
    colour_cycle_flag = 0
    gosub restore_default_colours

    sidx = S_CARPET
    gosub spawn_item

  bend : else begin

  spr_ox%(S_CARPET) = spr_ox%(S_GIRL) + 16
  spr_oy%(S_CARPET) = spr_oy%(S_GIRL) + 8
  bend

  return


'-------------
.cycle_colours
'-------------
  bank 0
  sys $7f21, $0a * 16, 16
  bank 128
  return


'-----------------------
.handle_carpet_collision
'-----------------------
  if colour_cycle_flag = 0 then begin
    colour_cycle_flag = 1
    cycle_start = ti
    girl_vx = 0
    girl_vy = 0

    sound snd_order(snd_idx), 4000, 50, 2, 2000, 200, 0
    snd_idx = mod(snd_idx + 1, 6)
  bend
  return


'------------------------
.handle_wbottle_collision
'------------------------
  score = score + 400
  water = water + 8

  gosub draw_score
  gosub draw_energy_bars

  k = fre(1)  ' do garbage collection after any string work

  sound snd_order(snd_idx), 5000, 30, 0, 1000, 600, 3
  snd_idx = mod(snd_idx + 1, 6)


  sidx = S_WBOTTLE
  gosub spawn_item

  return


'-----------------------
.handle_banana_collision
'-----------------------
  score = score + 200
  health = health + 2

  gosub draw_score
  gosub draw_energy_bars

  k = fre(1)  ' do garbage collection after any string work

  sound snd_order(snd_idx), 1000, 20, 1, 500, 50, 3
  snd_idx = mod(snd_idx + 1, 6)


  sidx = S_BANANA
  gosub spawn_item
  return


'--------------------
.handle_key_collision
'--------------------
  score = score + 100
  gosub draw_score
  k = fre(1)  ' do garbage collection after any string work

  sound snd_order(snd_idx), 5000, 10, 0, 3000, 200, 1
  snd_idx = mod(snd_idx + 1, 6)

  key_flag = 1

  spr_ox%(S_KEY) = 640  ' workaround to hide

  return


'---------------------
.handle_wolf_collision
'---------------------
  if colour_cycle_flag = 1 then begin
    sound snd_order(snd_idx), 5000, 43, 0, 400, 500, 1
    snd_idx = mod(snd_idx + 1, 6)

    score = score + 1000
    gosub draw_score
    k = fre(1)

    spr_ox%(S_WOLF1 + widx) = 640
    wolf_die(widx) = ti

  bend : else begin

    health = health - 1
    gosub draw_energy_bars
    k = fre(1)

    sound snd_order(snd_idx), 1000, 5, 2, 3000, 500, 1
    snd_idx = mod(snd_idx + 1, 6)


    if health = 0 then begin
      colour_cycle_flag = 0
      gosub restore_default_colours

      gosub clrscreen

      tclr = 2 : a$ = "You died a gruesome death!"
      pane_width% = len(a$) + 4
      pane_height% = 5
      gosub show_centred_pane

      ' sleep two secs with music polling
      end_time = ti
      do while (ti - end_time) < 2
        gosub parse_current_seqptr
      loop

      ' clear keyboard buffer
      for k = 0 to 16
        get a$
      next k
            
      game_over_flag = 1

    bend

  bend
  return


'-----------------
.show_centred_pane
'-----------------
  pane_x% = (80 - pane_width%) / 2
  pane_y% = (50 - pane_height%) / 2

  gosub draw_pane

  tclr = 0 : tx = pane_x% + 2 : ty = pane_y% + 2
  gosub draw_text

  return


'---------
.draw_pane
'---------
  bank 0
  poke $7e10, pane_x%
  poke $7e11, pane_y%
  poke $7e12, pane_width%
  poke $7e13, pane_height%
  sys $7f09
  bank 128
  return


'---------
.hide_pane
'---------
  bank 0
  poke $7e10, pane_x%
  poke $7e11, pane_y%
  poke $7e12, pane_width%
  poke $7e13, pane_height%
  sys $7f0c
  bank 128
  return


'----------
.init_level
'----------
  iter = 0

  wolf_speed = .1 + wolf_cnt / 10
  carpet_time = 10 + wolf_cnt * 3

  spr_ox%(S_GIRL) = 310
  spr_oy%(S_GIRL) = 220

  for k = 0 to WOLF_MAX

    wolf_x(k) = 100 + 400 * mod(k, 2)
    wolf_y(k) = 100 + 200 * int(k / 2)

    if k <= wolf_cnt then begin
      spr_ox%(S_WOLF1 + k) = wolf_x(k)
      spr_oy%(S_WOLF1 + k) = wolf_y(k)
    bend: else begin
      spr_ox%(S_WOLF1 + k) = 640
      spr_oy%(S_WOLF1 + k) = 0
    bend

    wolf_vx(k) = 0
    wolf_vy(k) = 0

  next k

  spr_fidx&(S_CHEST) = 0
  tmp = char_idx%(spr_frames&(S_CHEST, 0))
  spr_char_idx%(S_CHEST) = tmp

  game_over_flag = 0
  colour_cycle_flag = 0

  sidx = S_KEY
  gosub spawn_item

  sidx = S_BANANA
  gosub spawn_item

  sidx = S_WBOTTLE
  gosub spawn_item

  sidx = S_CARPET
  gosub spawn_item

  sidx = S_CHEST
  gosub spawn_item

  key_flag = 0

  for k = 0 to 3
    wolf_die(k) = 0
  next k

  for k = 0 to 2
    gem_x(k) = 640
    spr_ox%(S_GEM1 + k) = 640
  next k

  return


'----------
.spawn_item
'----------
  spr_ox%(sidx) = rnd(1)*580 + 10
  spr_oy%(sidx) = 32 +rnd(1)*340

  gosub check_box_collisions
  if spr_collide&(S_GIRL, sidx) <> 0 then goto spawn_item

  return


'------------
.baddie_logic
'------------

  for widx = 0 to wolf_cnt

    if wolf_die(widx) <> 0 then begin

      if (ti - wolf_die(widx)) > 10 then begin
        sidx = S_WOLF1 + widx
        gosub spawn_item

        wolf_x(widx) = spr_ox%(S_WOLF1 + widx)
        wolf_y(widx) = spr_oy%(S_WOLF1 + widx)
        wolf_vx(widx) = 0
        wolf_vy(widx) = 0

        wolf_die(widx) = 0
      bend

    bend

    if wolf_die(widx) <> 0 then goto cnt_widx

    dx = spr_ox%(S_GIRL) - spr_ox%(S_WOLF1 + widx)
    dy = spr_oy%(S_GIRL) - spr_oy%(S_WOLF1 + widx)

    radius = sqr(dx*dx + dy*dy)

    if dx <> 0 then dx = wolf_speed * dx / radius ' : else wolf_vx(widx) = 0
    if dy <> 0 then dy = wolf_speed * dy / radius ' : else wolf_vy(widx) = 0

    if colour_cycle_flag = 0 then begin
      wolf_vx(widx) = wolf_vx(widx) + dx
      wolf_vy(widx) = wolf_vy(widx) + dy
    bend : else : begin
      wolf_vx(widx) = wolf_vx(widx) - dx
      wolf_vy(widx) = wolf_vy(widx) - dy
    bend

    if wolf_vx(widx) > 5+widx then wolf_vx(widx) = 5+widx
    if wolf_vx(widx) < -5-widx then wolf_vx(widx) = -5-widx
    if wolf_vy(widx) > 5+widx then wolf_vy(widx) = 5+widx
    if wolf_vy(widx) < -5-widx then wolf_vy(widx) = -5-widx

    wolf_x(widx) = wolf_x(widx) + wolf_vx(widx)
    wolf_y(widx) = wolf_y(widx) + wolf_vy(widx)

    if wolf_x(widx) < 0 then wolf_x(widx) = 0 : gosub boing : wolf_vx(widx) = -wolf_vx(widx)
    if wolf_x(widx) > 607 then wolf_x(widx) = 607 : gosub boing : wolf_vx(widx) = -wolf_vx(widx)
    if wolf_y(widx) < 0 then wolf_y(widx) = 0 : gosub boing : wolf_vy(widx) = -wolf_vy(widx)
    if wolf_y(widx) > 367 then wolf_y(widx) = 367 : gosub boing : wolf_vy(widx) = -wolf_vy(widx)

    spr_ox%(S_WOLF1 + widx) = wolf_x(widx)
    spr_oy%(S_WOLF1 + widx) = wolf_y(widx)

.cnt_widx
  next widx

  return


'----------
.user_input
'----------
  get a$

  bank 128 : jval = peek($dc00)

  if colour_cycle_flag = 1 then gosub carpet_controls
  
  if colour_cycle_flag = 0 then gosub normal_controls
    
  if a$ = KEY_MEGA_Q then goto cleanup

  return


'---------------
.carpet_controls
'---------------
  if (not jval and 4) and girl_vx > -5 then begin
    girl_vx = girl_vx - 1
  bend

  if (not jval and 8) and girl_vx < 5 then begin
    girl_vx = girl_vx + 1
  bend

  if (not jval and 1) and girl_vy > -5 then begin
    girl_vy = girl_vy - 1
  bend

  if (not jval and 2) and girl_vy < 5 then begin
    girl_vy = girl_vy + 1
  bend

  spr_ox%(S_GIRL) = spr_ox%(S_GIRL) + girl_vx

  if spr_ox%(S_GIRL) < 0 then spr_ox%(S_GIRL) = 0 : gosub boing : girl_vx = -girl_vx
  if spr_ox%(S_GIRL) > 607 then spr_ox%(S_GIRL) = 607 : gosub boing : girl_vx = -girl_vx

  spr_oy%(S_GIRL) = spr_oy%(S_GIRL) + girl_vy

  if spr_oy%(S_GIRL) < 16 then spr_oy%(S_GIRL) = 16: gosub boing : girl_vy = -girl_vy
  if spr_oy%(S_GIRL) > 367 then spr_oy%(S_GIRL) = 367 : gosub boing : girl_vy = -girl_vy

  return


'---------------
.normal_controls
'---------------
  if (not jval and 4) then begin
    spr_ox%(S_GIRL) = spr_ox%(S_GIRL) - 3
    if spr_ox%(S_GIRL) < 0 then spr_ox%(S_GIRL) = 0
  bend

  if (not jval and 8) then begin
    spr_ox%(S_GIRL) = spr_ox%(S_GIRL) + 3
    if spr_ox%(S_GIRL) > 607 then spr_ox%(S_GIRL) = 607
  bend

  if (not jval and 1) then begin
    spr_oy%(S_GIRL) = spr_oy%(S_GIRL) - 3
    if spr_oy%(S_GIRL) < 16 then spr_oy%(S_GIRL) = 16
  bend

  if (not jval and 2) then begin
    spr_oy%(S_GIRL) = spr_oy%(S_GIRL) + 3
    if spr_oy%(S_GIRL) > 367 then spr_oy%(S_GIRL) = 367
  bend

  return

  
'----------
.draw_score
'----------
  tx = 0 : ty = 0 : tclr = 0
  a$ = "SCORE: " + str$(score)
  gosub draw_text
  return


'------------
.draw_hiscore
'------------
  tx = 40 : ty = 0 : tclr = 0
  a$ = hs_name$(wolf_cnt) + "'s HIGH SCORE: " + str$(hs_score(wolf_cnt))
  k = fre(1)
  gosub draw_text
  return


'----------------
.draw_energy_bars
'----------------
  tx = 0 : ty = 1 : tclr = 0
  a$ = "HEALTH: "
  gosub draw_text

  tx = 8 : tclr = 5
  a$ = KEY_REV_ON

  if health > 0 then begin
    if health > 30 then health = 30
    for k = 0 to health - 1
      a$ = a$ + " "
    next k
  bend

  a$ = a$ + KEY_REV_OFF + " "

  gosub draw_text


  ' - - - - - - -

  tx = 40 : ty = 1 : tclr = 0
  a$ = "WATER: "
  gosub draw_text

  tx = 48 : tclr = 6
  a$ = KEY_REV_ON

  if water > 0 then begin
    if water > 30 then water = 30
    for k = 0 to water - 1
      a$ = a$ + " "
    next k
  bend

  a$ = a$ + KEY_REV_OFF + " "

  gosub draw_text

  return


'---------------
.animate_objects
'---------------
  anim_tmr = mod (anim_tmr + 1, 8)

  if anim_tmr = 0 then begin
    for k = 0 to wolf_cnt
      fidx = spr_fidx&(S_WOLF1 + k)
      fidx = mod(fidx + 1, 2)
      spr_fidx&(S_WOLF1 + k) = fidx
      tmp = char_idx%(spr_frames&(S_WOLF1 + k, fidx))
      spr_char_idx%(S_WOLF1 + k) = tmp
    next k

    fidx = spr_fidx&(S_GIRL)
    fidx = mod(fidx + 1, 2)
    spr_fidx&(S_GIRL) = fidx
    tmp = char_idx%(spr_frames&(S_GIRL, fidx))
    spr_char_idx%(S_GIRL) = tmp
  bend

  return


'-----------
.draw_coords
'-----------
  tclr = 0 : tx = 5 : ty = 4
  a$ = "sprite index =" + str$(sidx)
  gosub draw_text
  tclr = 0 : tx = 5 : ty = 5
  a$ = "x =" + str$(spr_ox%(sidx)) + ", y =" + str$(spr_oy%(sidx)) + "     "
  
  ' force garbage collection now, so that it doesn't trigger
  ' during sys call and crash (due to my CLRPTR=$20 being a far-ptr in basic)
  k = fre(1)

  gosub draw_text
  return


'------------
.draw_objects
'------------
  vsync 250
'  border 3
  bank 0
  sys $7f00
  bank 128
  return


'--------------------
.check_box_collisions
'--------------------
  ' border 5
  bank 0
  sys $7f1e
  bank 128
  ' border 0

  return


'-----------------
.draw_text_centred
'-----------------
  tx = (80 - len(a$)) / 2
  gosub draw_text
  return


'---------
.draw_text
'---------
  bank 0
  poke $7e0d, tx
  poke $7e0e, ty
  poke $7e0f, tclr
  sys $7f03, 0, aptr_lo, aptr_hi
  bank 128

  return

  ' the above works, but occasionally trips up on basic garbage collection


'---------
.load_data
'---------
  char_count = 0

  if len(ln$) > 0 then begin
    dopen #2,(ln$),r,u8
    if ds then tclr = 2 : a$ = "disk error" : gosub draw_text : return

    get#2, frame_count%

    for k = 0 to frame_count% - 1
      get#2, xx : char_type(k) = xx and 255
      get#2, xx : default_slice(k) = xx and 255
      get#2, xx : chr_width%(k) = xx and 255
      get#2, xx : chr_height%(k) = xx and 255
      get#2, xx, yy
      char_idx%(k) = (xx and 255) + (yy and 255) * 256
      get#2, xx : bb_cnt&(k) = xx and 255
      if bb_cnt&(k) > 0 then begin
        for kk = 0 to bb_cnt&(k) - 1
          get#2, xx, yy : bb_tlx&(k,kk) = xx and 255 : bb_tly&(k,kk) = yy and 255
          get#2, xx, yy : bb_brx&(k,kk) = xx and 255 : bb_bry&(k,kk) = yy and 255
        next kk
      bend

      char_count = char_count + chr_width%(k) * chr_height%(k)
    next k

    ' todo : add animation details here
    get#2, xx : anim_count = xx and 255
    if anim_count > 0 then begin
      for k = 0 to anim_count - 1
        ' load number of frames in anim
        ' load list of frame indices
      next k
    bend

    for k = 0 to char_count * $40
      get#2, xx
      poke char_idx%(0) * $40 + k, xx and 255
    next k

    dclose #2

    if debug_bb = 1 then gosub draw_bounding_boxes

  bend

  return


'-------------------
.draw_bounding_boxes
'-------------------
  for fidx = 0 to frame_count% - 1
    if bb_cnt&(fidx) > 0 then begin
      for k = 0 to bb_cnt&(fidx) - 1

        for cx = bb_tlx&(fidx, k) to bb_brx&(fidx, k)
          cy = bb_tly&(fidx, k)
          gosub plot_pixel
          cy = bb_bry&(fidx, k)
          gosub plot_pixel
        next cx

        for cy = bb_tly&(fidx, k) to bb_bry&(fidx, k)
          cx = bb_tlx&(fidx, k)
          gosub plot_pixel
          cx = bb_brx&(fidx, k)
          gosub plot_pixel
        next cy

      next k
    bend
  next fidx

  return


'----------
.plot_pixel
'----------
  x = mod(cx, 8)
  y = mod(cy, 8)
  xx = int(cx / 8)
  yy = int(cy / 8)
  poke char_idx%(fidx) * $40 + $40 * chr_height%(fidx) * xx + $40 * yy + y * 8 + x, 1

  return


'---------------------
.store_default_colours
'---------------------
  for k = 0 to 15
    default_red&(k) = peek($d1a0+k)
    default_green&(k) = peek($d2a0+k)
    default_blue&(k) = peek($d3a0+k)
  next k

  return


'-----------------------
.restore_default_colours
'-----------------------
  for k = 0 to 15
    poke $d1a0+k, default_red&(k)
    poke $d2a0+k, default_green&(k)
    poke $d3a0+k, default_blue&(k)
  next k

  return


'---------
.load_song
'---------
  dopen #2,(song$),r,u8

  ' load melody chunks
  ' ------------------
  input #2, chunk_cnt
  for chunk_idx = 0 to chunk_cnt - 1
    for vidx=0 to 5
      input #2,v$(vidx, chunk_idx)
    next vidx
  next chunk_idx

  input #2,tmpo%

  tempo tmpo%
  
  ' load envelopes
  ' --------------
  for row = 0 to 9
    input #2, tmp$
    input #2, attack
    input #2, decay
    input #2, sustain
    input #2, release
    input #2, waveform
    input #2, pw

    envelope row, attack, decay, sustain, release, waveform, pw
  next row
  print

  ' load filter presets
  ' -------------------
  for row = 0 to 10
    input #2, tmp$
    input #2, tmp
    input #2, tmp
    input #2, tmp
    input #2, tmp
    input #2, tmp
    input #2, tmp
    input #2, tmp
    input #2, tmp
  next row

  ' load sequence
  ' -------------
  seqcnt = 0
  input #2, seqcnt
  row = 0
  do while row < seqcnt
    input #2, seq_chunk(row)
    input #2, seq_extra(row)
    row = row + 1
  loop


  dclose #2

  chunk_idx = 0
  return
ÿ