!to "asmhelper.prg", cbm

// DEFINES
// =======
ZEROPTR = $1c
ONEPTR = $29
FOURPTR = $18
CLRPTR = $20

// for megaplot (some overlap)
COLRBASE = $0000 // Fixed to Bank ff8
ROWPTR = $18
COLPTR = $1c
MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778


// BANK4 VAR INTERFACE
// ===================
DEFAULT_RED = $20
DEFAULT_GREEN = $22
DEFAULT_BLUE = $24
CURR_RED = $26
CURR_GREEN = $28
CURR_BLUE = $2a
DATA_ADDR = $2c	// src of dma
CDATA_ADDR = $2e
SCRADDR = $30	// dest of dma
CLRADDR = $32
INC_FRM = $34
STARX = $36
STARVX = $38

MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778

WIDTH = 250

// MACROS
// ======
!macro prepvar16 .array, .var {
  +copy16 ONEPTR, .array
  lda [ONEPTR],z
  tax  // store high byte
  inw ONEPTR
  lda [ONEPTR],z
  tay  // store low byte

  sty .var
  stx .var+1
}

!macro prepvar8 .array, .var {
  +copy16 ONEPTR, .array
  inw ONEPTR
  lda [ONEPTR],z
  tay  // store low byte

  sty .var
}

!macro copy16 .dest, .src {
	lda .src
	sta .dest
	lda .src+1
	sta .dest+1
}

!macro set16 .dest, .val {
	lda #<.val
	sta .dest
	lda #>.val
	sta .dest+1
}

!macro lsr16 .loc {
	clc
	lda .loc+1
	ror
	sta .loc+1
	lda .loc
	ror
	sta .loc
}

!macro lsr16_by .loc, .cnt {
	ldx #.cnt
	cpx #$00
	beq +
-	+lsr16 .loc
	dex
	bne -
+ 
}

!macro copy_basic_int .bk4loc, .out {
	+set0ptr_from_4ptr .bk4loc
	ldz #$00
	lda [ZEROPTR],z
	sta .out+1
	inz
	lda [ZEROPTR],z
	sta .out
}

!macro set0ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ZEROPTR
	inz
	lda [FOURPTR],z
	sta ZEROPTR+1
	plz
}

!macro set1ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ONEPTR
	inz
	lda [FOURPTR],z
	sta ONEPTR+1
	plz
}

!macro add16 .in1, .in2, .out {
	clc
	lda .in1
	adc .in2
	sta .out
	lda .in1+1
	adc .in2+1
	sta .out+1
	clc
}

!macro subtract16 .in1, .in2, .out {
	sec
	lda .in1
	sbc .in2
	sta .out
	lda .in1+1
	sbc .in2+1
	sta .out+1
	clc
}

!macro multiply16 .in1, .in2, .out {
	phz
  phy
  phx
	ldz #$00
	ldy #$00
	ldx .in1+1
	lda .in1
	stq MULTINA

	ldx .in2+1
	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out+1
	sta .out
  plx
  ply
	plz
}

!macro multiply8 .in1, .in2, .out {
	phz
	ldz #$00
	ldy #$00
	ldx #$00
	lda .in1
	stq MULTINA

	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out+1
	sta .out
	plz
}

!macro wpoke_b4 .offs, .intvar {
	ldz#.offs
	lda .intvar
	sta [FOURPTR],z
	inz
	lda .intvar+1
	sta [FOURPTR],z
}

!macro poke_b4 .offs, .bytevar {
	ldz#.offs
	lda .bytevar
	sta [FOURPTR],z
}

!macro poke_b4_val .offs, .byte {
	ldz#.offs
	lda#.byte
	sta [FOURPTR],z
}

!macro fade_clr1_to_white_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $f0   ' (white)
	sta clr2
	lda #$f0
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_black_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $00   ' (black)
	sta clr2
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_clr2_step .bk4ptr1, .bk4ptr2, .palette_loc {
	// flip_var = curr_red&(k)
	+set1ptr_from_4ptr .bk4ptr1
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr2
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr2 = flip_var
	sta clr2+1
	lda #$00
	sta clr2
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro edma_transp .transp, .cmd, .length, .src_addr, .src_bank, .dst_addr, .dst_bank, .dst_mb {
	!byte $81	// dest addr MB selector
	!byte .dst_mb	// destination megabyte
	!byte $07	// enable transparency
	!byte $86	// set transparency
	!byte .transp	// transparency value
	!byte $00	// end of options

	!byte .cmd	// CMD = COPY + chain

	!word .length	// length
	!word .src_addr	// src addr = $54000
	!byte .src_bank	// src bank = $05
	!word .dst_addr	// dest addr = $54000
	!byte .dst_bank	// dest bank = $05
	!byte $00	// CMD msb (ignore)
	!word $0000	// modulo (ignore)
}

!macro edma .cmd, .length, .src_addr, .src_bank, .dst_addr, .dst_bank, .dst_mb {
	!byte $06	// disable transparency
	!byte $81	// dest addr MB selector
	!byte .dst_mb	// destination megabyte
	!byte $00	// end of options

	!byte .cmd	// CMD = COPY + chain

	!word .length	// length
	!word .src_addr	// src addr = $54000
	!byte .src_bank	// src bank = $05
	!word .dst_addr	// dest addr = $54000
	!byte .dst_bank	// dest bank = $05
	!byte $00	// CMD msb (ignore)
	!word $0000	// modulo (ignore)
}

// INTERFACE VARS
// ==============
* = $1600

// draw-objects vars
array_objx: !word $00           // 1600
array_objy: !word $00           // 1602
array_chr_width: !word $00      // 1604
array_chr_height: !word $00     // 1606
array_char_idx: !word $00       // 1608
array_stage_x_offs: !word $00   // 160A
spr_count: !byte $00            // 160C

// draw-text vars
tx: !byte $00                   // 160D
ty: !byte $00                   // 160E
tclr: !byte $00                 // 160F


// ROUTINES
// ========
* = $1610
  jmp draw_objects    // 1610
  jmp draw_text       // 1613


//-------
draw_text:
//-------
// input:
//   x = string low-ptr
//   y = string high-ptr
  stx ZEROPTR
  sty ZEROPTR+1
  lda #$00
  sta ZEROPTR+2
  sta ZEROPTR+3

  // prepare pointer to string in ONEPTR
  ldz #$00
  lda [ZEROPTR],z
  sta stringlen
  inz
  lda [ZEROPTR],z
  sta ONEPTR
  inz
  lda [ZEROPTR],z
  sta ONEPTR+1
  lda #$01
  sta ONEPTR+2
  lda #$00
  sta ONEPTR+3

//   idx = 0

//   rev_flag = 0
  sta rev_flag

// prepare FOURPTR before loop starts
//     wpoke $40800 + ty * WIDTH + (tx + idx) * 2, chr
    clc
    lda tx
    rol
    sta inputw1
    lda #$00
    adc #$00
    sta inputw1+1

    lda #WIDTH
    sta tmp
    +multiply8 ty, tmp, inputw2

    +add16 inputw1, inputw2, inputw1

    lda #$00
    sta inputw2
    lda #$08
    sta inputw2+1
    +add16 inputw1, inputw2, FOURPTR

    lda #$04
    sta FOURPTR+2
    lda #$00
    sta FOURPTR+3

// prepare CLRPTR before loop starts
//     poke $ff80000 + ty * WIDTH + (tx + idx) * 2 + 1, tclr
    lda inputw1
    sta CLRPTR
    lda inputw1+1
    sta CLRPTR+1
    lda #$f8
    sta CLRPTR+2
    lda #$0f
    sta CLRPTR+3

//   for k = 1 to len(a$)
  ldz #$00
  stz kptr
//     chr = asc(mid$(a$,k,1))
-:
  ldz kptr
  lda [ONEPTR],z
  sta chr
//     if mid$(a$,k,1) = KEY_REV_ON then rev_flag = 1 : goto nxtdt
    cmp #18 // KEY_REV_ON
    bne +
      lda #$01
      sta rev_flag
      lbra ++

+:
//     if mid$(a$,k,1) = KEY_REV_OFF then rev_flag = 0 : goto nxtdt
    cmp #146 // KEY_REV_OFF
    bne +
      lda #$00
      sta rev_flag
      lbra ++
+:
// 
//     gosub petscii_to_screencode
    jsr petscii_to_screencode
// 
//     if rev_flag = 1 then chr = chr or $80
    ldx rev_flag
    beq +
      lda chr
      ora #$80
      sta chr
+:

//     wpoke $40800 + ty * WIDTH + (tx + idx) * 2, chr
    ldz #$00
    lda chr
    sta [FOURPTR],z
    inz
    lda #$00
    sta [FOURPTR],z

    inw FOURPTR
    bne +
    inw FOURPTR+2
+:
    inw FOURPTR
    bne +
    inw FOURPTR+2
+:
//     poke $ff80000 + ty * WIDTH + (tx + idx) * 2 + 1, tclr
    ldz #$01
    lda tclr
    sta [CLRPTR],z

    inw CLRPTR
    bne +
    inw CLRPTR+2
+:
    inw CLRPTR
    bne +
    inw CLRPTR+2
+:

//     idx = idx + 1
// .nxtdt
++:
//   next k
  ldz kptr
  inz
  stz kptr
  cpz stringlen
  lbne -
//   return
  rts


//-------------------
petscii_to_screencode:
//-------------------
//  if chr>=$00 and chr<=$1f then chr = chr or $80 : return
  lda chr
  cmp #$20
  bcs +
    ora #$80
    sta chr
    rts
//  if chr>=$20 and chr<=$3f then return
+:
  cmp #$40
  bcs +
    rts
//  if chr>=$40 and chr<=$5f then chr=chr and $bf : return
+:
  cmp #$60
  bcs +
    and #$bf
    sta chr
    rts
//  if chr>=$60 and chr<=$7f then chr=chr and $df : return
+:
  cmp #$80
  bcs +
    and #$df
    sta chr
    rts
//  if chr>=$80 and chr<=$9f then chr=chr or $40 : return
+:
  cmp #$a0
  bcs +
    ora #$40
    sta chr
    rts
//  if chr>=$a0 and chr<=$bf then chr=(chr and $7f) or $40 : return
+:
  cmp #$c0
  bcs +
    and #$7f
    ora #$40
    sta chr
    rts
//  if chr>=$c0 and chr<=$fe then chr=chr and $7f : return
+:
  cmp #$ff
  bcs +
    and #$7f
    sta chr

+:
  rts

//-----------
draw_objects:
//-----------
//   - word array_objx@1600
//   - word array_objy@1602
//   - byte array_chr_width@1604
//   - byte array_chr_height@1606
//   - word array_char_idx@1608
//   - word array_stage_x_offs@160a
//   - byte spr_count@160c

//  old_sidx = sidx
    // skip this, not needed

//  for sidx = 0 to spr_count% - 1
    lda #$00
    sta sidx
-:
//    gosub draw_object
    jsr prepare_vars
    jsr draw_object
//  next sidx
    inc sidx
    lda sidx
    cmp spr_count
    bne -

//  sidx = old_sidx
//  return
  rts


//----------
prepare_vars:
//----------
  // prepare one pointer
  lda #$00
  sta ONEPTR+3
  lda #$01
  sta ONEPTR+2

  // let z hold the byte-offset to the array we need
  lda sidx
  clc
  rol
  taz

  +prepvar16 array_objx, objx
  +prepvar16 array_objy, objy
  +prepvar8  array_chr_width, chr_width
  +prepvar8  array_chr_height, chr_height
  +prepvar16 array_char_idx, char_idx
  +prepvar16 array_stage_x_offs, stage_x_offs

  rts

//---------
draw_object:
//---------
// input:
//   - word objx@1600
//   - word objy@1602
//   - byte chr_width@1604
//   - byte chr_height@1605
//   - word char_idx@1606
//   - word stage_x_offs@1608

//  yy = int(objy / 8)
    lda #$02
    sta $d020

    clc
    lda stage_x_offs
    rol
    sta stage_x_offs
    lda stage_x_offs+1
    rol
    sta stage_x_offs+1

    +copy16 tempval, objy
    +lsr16_by tempval, 3
    lda tempval
    sta yy

//  yybot = yy + chr_height(sidx) ' - 1
    lda yy
    clc
    adc chr_height
    sta yybot

//  offsy = mod(objy, 8)
    lda objy
    and #$07
    sta offsy

//  ' clear prior position (if needbe)
//  if oldyy <> INVALID and yy <> oldyy then begin
    ldx sidx
    lda array_oldyy,x
    sta oldyy
    cmp #$80
    lbeq skip_clear_old_position

    cmp yy
    lbeq skip_clear_old_position

//    minyy = oldyy
      lda oldyy
      sta minyy

//    maxyy = oldyy + chr_height(sidx) ' - 1
      clc
      adc chr_height
      sta maxyy

//    if minyy < yy and yy < maxyy then maxyy = yy - 1
      lda minyy
      cmp yy
      bcs skip_adjust_maxyy

      lda yy
      cmp maxyy
      bcs skip_adjust_maxyy

        ldx yy
        dex
        stx maxyy

skip_adjust_maxyy:

//    if minyy < yybot and yybot < maxyy then minyy = yybot + 1
      lda minyy
      cmp yybot
      bcs skip_adjust_minyy

      lda yybot
      cmp maxyy
      bcs skip_adjust_minyy

        ldx yybot
        inx
        stx minyy
skip_adjust_minyy:

//    ' hide these rows off-screen
//    for y = minyy to maxyy
      ldy minyy
-:
      //      wpoke $40800 + y * WIDTH + stage_x_offs(sidx) * 2 + 160, 80 * 8 
        // outputw = y * WIDTH
        sty inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + $800 + 160
        lda #160
        sta inputw2
        lda #$08
        sta inputw2+1
        +add16 outputw, inputw2, outputw

        // set 4-pointer
        lda outputw
        sta FOURPTR
        lda outputw+1
        sta FOURPTR+1
        lda #$04
        sta FOURPTR+2
        lda #$00
        sta FOURPTR+3
     
        // wpoke to value 80 * 8 = 640 = $0280
        ldz #$00
        lda #$80
        sta [FOURPTR],z
        inz
        lda #$02
        sta [FOURPTR],z

      iny
      cpy maxyy
      lbcc -
      lbeq -
//    next y
//  bend
skip_clear_old_position:

//
//  vsync 250
//  border 2
//
//  ' draw chars on desired yrows, and at right objx position
//  char_idx = char_idx(sidx)

//  tmpx = chr_width(sidx) - 1
    ldx chr_width
    dex
    stx tmpx

//  tmpy = chr_height(sidx) - 1
    ldx chr_height
    dex
    stx tmpy

//  for x = 0 to tmpx
    ldx #$00
lpx:
//    for y = 0 to tmpy
      ldy #$00
lpy:
//      k = $40800 + (yy + y) * WIDTH + stage_x_offs(sidx) * 2 + 162 + x * 2

        // outputw = yy + y
        lda yy
        sta inputw1
        lda #$00
        sta inputw1+1

        sty inputw2
        lda #$00
        sta inputw2+1

        +add16 inputw1, inputw2, outputw

        // outputw = outputw * WIDTH
        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 outputw, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + $800 + 162 = 8A2
        lda #162
        sta inputw2
        lda #$08
        sta inputw2+1
        +add16 outputw, inputw2, outputw

        // outputw = outputw + x * 2
        txa
        clc
        rol
        sta inputw1
        lda #$00
        adc #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

        // set 4-pointer
        lda outputw
        sta FOURPTR
        lda outputw+1
        sta FOURPTR+1
        lda #$04
        sta FOURPTR+2
        lda #$00
        sta FOURPTR+3

//      wpoke k, char_idx
        ldz #$00
        lda char_idx
        sta [FOURPTR],z
        inz
        lda char_idx+1
        sta [FOURPTR],z

//      ' copy last y-line an extra line below (to help with y scrolling)
//      if y = tmpy then begin
        cpy tmpy
        bne skip_copy_last_line_twice
//        wpoke k + WIDTH, char_idx
          ldz #WIDTH
          lda char_idx
          sta [FOURPTR],z
          inz
          lda char_idx+1
          sta [FOURPTR],z

//      bend
skip_copy_last_line_twice:
//
//      char_idx = char_idx + 1
        clc
        lda char_idx
        adc #$01
        sta char_idx
        lda char_idx+1
        adc #$00
        sta char_idx+1

//    next y   //    for y = 0 to tmpy
      iny
      cpy tmpy
      lbcc lpy
      lbeq lpy
  
//  next x
    inx
    cpx tmpx
    lbcc lpx
    lbeq lpx

//  ' handle negative x
//  x = objx
//  if objx < 0 then x = 1024 + objx
    lda objx+1
    and #%00000011  // only need first two bits of high byte
    sta objx+1

//  k (aka tempval) = x + (offsy * 32 + 16) * 256

    lda offsy
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    ora #$10
    sta tempval+1
    lda objx
    sta tempval
    clc
    lda objx+1
    adc tempval+1
    sta tempval+1

//  ' set initial rowmask
//  tmp = $ff80000 + yy * WIDTH + stage_x_offs(sidx) * 2 + 160

        // outputw = outputw * WIDTH
        lda yy
        sta inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + 160
        lda #160
        sta inputw1
        lda #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

        // set clr-pointer
        lda outputw
        sta CLRPTR
        lda outputw+1
        sta CLRPTR+1
        lda #$f8
        sta CLRPTR+2
        lda #$0f
        sta CLRPTR+3
  
//  poke tmp, %10011000
        ldz #$00
        lda #%10011000
        sta [CLRPTR],z

//  poke tmp + 1, 255 << offsy and 255

    lda #$ff
    ldx offsy
    cpx #$00
    beq +
-   clc
    rol
    dex
    bne -
+ 
    ldz #$01
    sta [CLRPTR],z

//  ' set initial gotox char
    lda yy
    clc
    adc tmpy
    sta maxyy

//  for y = yy to yy + tmpy
    ldy yy
lpyy:
//    tmp = y * WIDTH + stage_x_offs(sidx) * 2 + 160
        // outputw = y * WIDTH
        sty inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + 160
        lda #160
        sta inputw1
        lda #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

//    if y <> yy then begin
      cpy yy
      beq skip_poke
//      poke $ff80000 + tmp, %10010000
        // set clr-pointer
        lda outputw
        sta CLRPTR
        lda outputw+1
        sta CLRPTR+1
  
        ldz #$00
        lda #%10010000
        sta [CLRPTR],z
        
//    bend
skip_poke:

//    wpoke $40800 + tmp, k
      clc
      lda outputw
      sta FOURPTR
      lda outputw+1
      adc #$08
      sta FOURPTR+1

      ldz #$00
      lda tempval
      sta [FOURPTR],z
      inz
      lda tempval+1
      sta [FOURPTR],z

//  next y
    iny
    cpy maxyy
    lbcc lpyy
    lbeq lpyy
    
//  ' set final yoffs
//  k (tempval) = x + ( ((8-offsy) and 7) * 32) * 256

    lda #$08
    sec
    sbc offsy
    and #$07
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    sta tempval+1
    lda objx
    sta tempval
    clc
    lda objx+1
    adc tempval+1
    sta tempval+1

      // outputw = yybot * WIDTH
      lda yybot
      sta inputw1
      lda #$00
      sta inputw1+1

      lda #WIDTH
      sta inputw2
      lda #$00
      sta inputw2+1
      +multiply16 inputw1, inputw2, outputw

      +add16 outputw, stage_x_offs, outputw

      // outputw = outputw + 160
      lda #160
      sta inputw1
      lda #$00
      sta inputw1+1

      +add16 outputw, inputw1, outputw

//  wpoke $40800 + yybot * WIDTH + stage_x_offs(sidx) * 2 + 160, k
      lda outputw
      sta FOURPTR
      clc
      lda outputw+1
      adc #$08
      sta FOURPTR+1

      ldz #$00
      lda tempval
      sta [FOURPTR],z
      inz
      lda tempval+1
      sta [FOURPTR],z

//  ' set final rowmask
//  tmp = $ff80000 + yybot * WIDTH + stage_x_offs(sidx) * 2 + 160
    lda outputw
    sta CLRPTR
    lda outputw+1
    sta CLRPTR+1

//  poke tmp, %10011000
    ldz #$00
    lda #%10011000
    sta [CLRPTR],z

//  poke tmp + 1, 255 >> (8 - offsy) and 255
    lda #$08
    sec
    sbc offsy
    tax

    lda #$ff
    cpx #$00
    beq +
-   clc
    ror
    dex
    bne -
+
    inz
    sta [CLRPTR],z

//  oldyy = yy
    lda yy
    ldx sidx
    sta array_oldyy,x
//
//  border 0
//  return

    lda #$00
    sta $d020
  rts


// VARIABLES
// ---------
yy: !byte $00
yybot: !byte $00
offsy: !byte $00
oldyy: !byte $80    // $80 = invalid value initially
minyy: !byte $00
maxyy: !byte $00
inputw1: !word $00
inputw2: !word $00
outputw: !word $00
tmpx: !byte $00
tmpy: !byte $00
tempval: !word $00
sidx: !byte $00

objx: !word $00
objy: !word $00
chr_width: !byte $00
chr_height: !byte $00
char_idx: !word $00  // aka. char_idx
stage_x_offs: !word $00
array_oldyy: !fill 100, $80

// draw_text
rev_flag: !byte $00
stringlen: !byte $00
chr: !byte $00
tmp: !byte $00
kptr: !byte $00
