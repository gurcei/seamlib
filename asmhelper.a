!to "asmhelper.prg", cbm

// DEFINES
// =======
ZEROPTR = $1c
  PTR1 = $1c
ONEPTR = $29
  PTR2 = $29
FOURPTR = $18
  PTR3 = $18
CLRPTR = $20
  PTR4 = $20

// for megaplot (some overlap)
COLRBASE = $0000 // Fixed to Bank ff8
ROWPTR = $18
COLPTR = $1c
MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778


// BANK4 VAR INTERFACE
// ===================
DEFAULT_RED = $20
DEFAULT_GREEN = $22
DEFAULT_BLUE = $24
CURR_RED = $26
CURR_GREEN = $28
CURR_BLUE = $2a
DATA_ADDR = $2c	// src of dma
CDATA_ADDR = $2e
SCRADDR = $30	// dest of dma
CLRADDR = $32
INC_FRM = $34
STARX = $36
STARVX = $38

MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778

WIDTH = 250

OP_COPY = 0
OP_MIX  = 1
OP_SWAP = 2
OP_FILL = 3

// MACROS
// ======
!macro get_indexed_val8_in_multidim_dptr .outv8, .array, .d1size, .d1idxv8, .d2idxv8 {
  +prepare_dptr_to_array PTR1, $0001, .array
  +inc_multidim_dptr_by_v8 PTR1, .d1size, .d2idxv8
  ldz .d1idxv8
  +set_v8_to_val_dptr .outv8, PTR1
}

!macro set_indexed_val8_in_multidim_dptr_to_v8 .array, .d1size, .d1idxv8, .d2idxv8, .v8in {
  +prepare_dptr_to_array PTR1, $0001, .array
  +inc_multidim_dptr_by_chunkv8_and_v8 PTR1, .d1size, .d2idxv8
  ldz .d1idxv8
  +set_val_dptr_to_v8 PTR1, .v8in
}

!macro inc_multidim_dptr_by_v8 .dptr, .chunksize, .var8 {
  +set16 inputw1, .chunksize
  +copy8to16 inputw2, .var8
  +multiply16 inputw1, inputw2, outputw
  +add32v16 .dptr, outputw
}

!macro inc_multidim_dptr_by_chunkv8_and_v8 .dptr, .chunksizev8, .var8 {
  +copy8to16 inputw1, .chunksizev8
  +copy8to16 inputw2, .var8
  +multiply16 inputw1, inputw2, outputw
  +add32v16 .dptr, outputw
}

!macro read_v8_from_dptr_and_inc .dptr, .var8 {
  ldz #$00
  +set_v8_to_val_dptr .var8, .dptr
  +inc32 PTR1
  +copy32 .dptr, PTR1
}

// NOTE: basic ints are stored as big-endian
!macro read_v16_be_from_dptr_and_inc .dptr, .var16 {
  ldz #$00
  +set_v8_to_val_dptr .var16+1, .dptr
  inz
  +set_v8_to_val_dptr .var16, .dptr
  +inc32 PTR1
  +inc32 PTR1

  +copy32 .dptr, PTR1
}

!macro set_v8_to_val_dptr .var8, .dptr {
  +copy32 PTR1, .dptr
  lda [PTR1],z
  sta .var8
}

!macro set_val_dptr_to_v8 .dptr, .var8 {
  lda .var8
  sta [.dptr],z
}

!macro prepare_dptr_to_array .dptr, .bank, .array {
  +set16 .dptr+2, .bank
  +copy16 .dptr, .array
}

!macro prepare_dptr_to_array_at_byte_idx_v8 .dptr, .bank, .array, .byte_idx_v8 {
  +prepare_dptr_to_array .dptr, .bank
  +add32v8 .dptr, .byte_idx_v8
}

!macro add16v8 .var16, .var8 {
  clc
  lda .var16
  adc .var8
  sta .var16

  lda .var16+1
  adc #$00
  sta .var16+1
}

!macro add32v8 var32, var8 {
  clc
  lda .var32
  adc .var8
  sta .var32

  lda .var32+1
  adc #$00
  sta .var32+1

  lda .var32+2
  adc #$00
  sta .var32+2

  lda .var32+3
  adc #$00
  sta .var32+3
}

!macro add32v16 .var32, .var16 {
  clc
  lda .var32
  adc .var16
  sta .var32

  lda .var32+1
  adc .var16+1
  sta .var32+1

  lda .var32+2
  adc #$00
  sta .var32+2

  lda .var32+3
  adc #$00
  sta .var32+3
}

!macro prepare_oneptr_to_word_idx .idx {
  // prepare one pointer
  lda #$00
  sta ONEPTR+3
  lda #$01
  sta ONEPTR+2

  // let z hold the byte-offset to the array we need
  lda .idx
  clc
  rol
  taz
}

!macro cmp8v8 .var1, .var2 {
  lda .var1
  cmp .var2
}

!macro cmp8 .var, .val {
  lda .var
  cmp #.val
}

!macro lsl8_by_v8 .var, .v8 {
  phx
  ldx .v8
  lda .var
-:
  cpx #$00
  beq +

  clc
  rol

  dex
  bra -

+:
  sta .var
  plx
}

!macro lsl8_by .var, .cnt {
  phx
  ldx #.cnt
  lda .var
-:
  cpx #$00
  beq +

  clc
  rol

  dex
  bra -

+:
  sta .var
  plx
}

!macro lsla .cnt {
  phx
  ldx #.cnt
-:
  cpx #$00
  beq +

  clc
  rol

  dex
  bra -

+:
  plx
}

!macro add8v8 .var1, .var2 {
  clc
  lda .var1
  adc .var2
  sta .var1
}

!macro add8 .var, .val {
  clc
  lda .var
  adc #.val
  sta .var
}

!macro inc8 .var8 {
  lda .var8
  clc
  adc #$01
  sta .var8
  clc
}

!macro dec8 .var8 {
  lda .var8
  sec
  sbc #$01
  sta .var8
  clc
}

!macro inc32 .var32 {
  inw .var32
  bne .skip
  inw .var32+2
.skip:
}

!macro inc32_dptr_twice .dptr {
  +copy32 PTR1, .dptr
  +inc32 PTR1
  +inc32 PTR1
  +copy32 .dptr, PTR1
}

!macro prepvar16 .array, .var {
  +copy16 ONEPTR, .array
  lda [ONEPTR],z
  tax  // store high byte
  inw ONEPTR
  lda [ONEPTR],z
  tay  // store low byte

  sty .var
  stx .var+1
}

!macro prepvar8 .array, .var {
  +copy16 ONEPTR, .array
  inw ONEPTR
  lda [ONEPTR],z
  tay  // store low byte

  sty .var
}

!macro copy8 .dest, .src {
  lda .src
  sta .dest
}

!macro copy16 .dest, .src {
	lda .src
	sta .dest
	lda .src+1
	sta .dest+1
}

!macro copy32 .dest, .src {
	lda .src
	sta .dest
	lda .src+1
	sta .dest+1
	lda .src+2
	sta .dest+2
	lda .src+3
	sta .dest+3
}

!macro copy8to16 .dest, .src {
	lda .src
	sta .dest
	lda #$00
	sta .dest+1
}

!macro set16 .dest, .val {
	lda #<.val
	sta .dest
	lda #>.val
	sta .dest+1
}

!macro set8 .dest, .val {
	lda #.val
	sta .dest
}

!macro lsr16 .loc {
	clc
	lda .loc+1
	ror
	sta .loc+1
	lda .loc
	ror
	sta .loc
}

!macro lsl16 .loc {
  clc
  lda .loc
  rol
  sta .loc
  lda .loc+1
  rol
  sta .loc+1
}

!macro lsr16_by .loc, .cnt {
	ldx #.cnt
	cpx #$00
	beq +
-	+lsr16 .loc
	dex
	bne -
+ 
}

!macro copy_basic_int .bk4loc, .out {
	+set0ptr_from_4ptr .bk4loc
	ldz #$00
	lda [ZEROPTR],z
	sta .out+1
	inz
	lda [ZEROPTR],z
	sta .out
}

!macro set0ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ZEROPTR
	inz
	lda [FOURPTR],z
	sta ZEROPTR+1
	plz
}

!macro set1ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ONEPTR
	inz
	lda [FOURPTR],z
	sta ONEPTR+1
	plz
}

!macro add16 .in1, .in2, .out {
	clc
	lda .in1
	adc .in2
	sta .out
	lda .in1+1
	adc .in2+1
	sta .out+1
	clc
}

!macro subtract16 .in1, .in2, .out {
	sec
	lda .in1
	sbc .in2
	sta .out
	lda .in1+1
	sbc .in2+1
	sta .out+1
	clc
}

!macro multiply16 .in1, .in2, .out {
	phz
  phy
  phx
	ldz #$00
	ldy #$00
	ldx .in1+1
	lda .in1
	stq MULTINA

	ldx .in2+1
	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out+1
	sta .out
  plx
  ply
	plz
}

!macro multiply8 .in1, .in2, .out {
	phz
	ldz #$00
	ldy #$00
	ldx #$00
	lda .in1
	stq MULTINA

	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out+1
	sta .out
	plz
}

!macro wpoke_b4 .offs, .intvar {
	ldz#.offs
	lda .intvar
	sta [FOURPTR],z
	inz
	lda .intvar+1
	sta [FOURPTR],z
}

!macro poke_b4 .offs, .bytevar {
	ldz#.offs
	lda .bytevar
	sta [FOURPTR],z
}

!macro poke_b4_val .offs, .byte {
	ldz#.offs
	lda#.byte
	sta [FOURPTR],z
}

!macro fade_clr1_to_white_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $f0   ' (white)
	sta clr2
	lda #$f0
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_black_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $00   ' (black)
	sta clr2
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_clr2_step .bk4ptr1, .bk4ptr2, .palette_loc {
	// flip_var = curr_red&(k)
	+set1ptr_from_4ptr .bk4ptr1
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr2
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr2 = flip_var
	sta clr2+1
	lda #$00
	sta clr2
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro edma_transp .transp, .cmd, .length, .src_addr, .src_bank, .dst_addr, .dst_bank, .dst_mb {
	!byte $81	// dest addr MB selector
	!byte .dst_mb	// destination megabyte
	!byte $07	// enable transparency
	!byte $86	// set transparency
	!byte .transp	// transparency value
	!byte $00	// end of options

	!byte .cmd	// CMD = COPY + chain

	!word .length	// length
	!word .src_addr	// src addr = $54000
	!byte .src_bank	// src bank = $05
	!word .dst_addr	// dest addr = $54000
	!byte .dst_bank	// dest bank = $05
	!byte $00	// CMD msb (ignore)
	!word $0000	// modulo (ignore)
}

!macro edma .cmd, .length, .src_addr, .src_bank, .dst_addr, .dst_bank, .dst_mb {
	!byte $06	// disable transparency
	!byte $81	// dest addr MB selector
	!byte .dst_mb	// destination megabyte
	!byte $00	// end of options

	!byte .cmd	// CMD = COPY + chain

	!word .length	// length
	!word .src_addr	// src addr = $54000
	!byte .src_bank	// src bank = $05
	!word .dst_addr	// dest addr = $54000
	!byte .dst_bank	// dest bank = $05
	!byte $00	// CMD msb (ignore)
	!word $0000	// modulo (ignore)
}

// INTERFACE VARS
// ==============
* = $7e00

// draw-objects vars
array_objx: !word $00           // 7E00  (spr_ox%[])
array_objy: !word $00           // 7E02  (spr_oy%[])
array_chr_width: !word $00      // 7E04  (chr_width%[])
array_chr_height: !word $00     // 7E06  (chr_height%[])
array_char_idx: !word $00       // 7E08  (char_idx%[])
array_stage_x_offs: !word $00   // 7E0A  (stage_x_offs%[])
spr_count: !byte $00            // 7E0C

// draw-text vars
tx: !byte $00                   // 7E0D
ty: !byte $00                   // 7E0E
tclr: !byte $00                 // 7E0F

// draw-pane vars
pane_x: !byte $00                // 7E10
pane_y: !byte $00                // 7E11
pane_width: !byte $00            // 7E12
pane_height: !byte $00           // 7E13

// plot_char
value: !word $00                 // 7E14

// draw_frame_contents
chr_width: !byte $00            // 7E16
chr_height: !byte $00           // 7E17
char_idx: !word $00             // 7E18

array_spr_fidx: !word $00       // 7E1A  (spr_fidx&[])
array_spr_frames: !word $00     // 7E1C  (spr_frames&(sidx, sfidx)
array_bb_cnt: !word $00         // 7E1E  (bb_cnt&[])
array_bb_tlx: !word $00         // 7E20  (bb_tlx&[][])
array_bb_tly: !word $00         // 7E22  (bb_tly&[][])
array_bb_brx: !word $00         // 7E24  (bb_brx&[][])
array_bb_bry: !word $00         // 7E26  (bb_bry&[][])
array_spr_collide: !word $00    // 7E28  (spr_collide&[][])


// ROUTINES
// ========
* = $7f00
  jmp draw_objects    // 7F00
  jmp draw_text       // 7F03
  jmp clrscreen       // 7F06
  jmp draw_pane        // 7F09
  jmp hide_pane        // 7F0C
  jmp plot_char       // 7F0F
  jmp clear_pane_insides   // 7F12
  jmp draw_frame_contents  // 7F15
  jmp draw_frame           // 7F18
  jmp preserve_data_behind_pane  // 7F1B
  jmp check_box_collisions  // 7F1E
  jmp cycle_alt_palette     // 7F21


//---------------
cycle_alt_palette:
//---------------  // a = base colour to start from (e.g. y=12 means cycle from 12 to 31(
	tay

	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// tempr = peek($d100+12)
	lda $d100,y
	sta tempr
	// tempg = peek($d200+12)
	lda $d200,y
	sta tempg
	// tempb = peek($d300+12)
	lda $d300,y
	sta tempb

	// for k = 12 to 30
	tya
	tax
		// poke $d100+k, peek($d100+k+1)
-		lda $d101,x
		sta $d100,x
		// poke $d200+k, peek($d200+k+1)
		lda $d201,x
		sta $d200,x
		// poke $d300+k, peek($d300+k+1)
		lda $d301,x
		sta $d300,x
	// next k
	inx
	cpx #31
	bne -

	// poke $d100+31, tempr
	lda tempr
	sta $d100+31
	// poke $d200+31, tempg
	lda tempg
	sta $d200+31
	// poke $d300+31, tempb
	lda tempb
	sta $d300+31
	
	// ----------------------------

do_curr:
	tya
	taz
	// tempr = curr_red&(12)
	+set1ptr_from_4ptr CURR_RED
	lda [ONEPTR],z
	sta tempr
	// tempg = curr_green&(12)
	+set1ptr_from_4ptr CURR_GREEN
	lda [ONEPTR],z
	sta tempg
	// tempb = curr_blue&(12)
	+set1ptr_from_4ptr CURR_BLUE
	lda [ONEPTR],z
	sta tempb

	// for k = 12 to 30
	tya
	taz
		// curr_red&(k) = curr_red&(k+1)
-		+set1ptr_from_4ptr CURR_RED
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// curr_green&(k) = curr_green&(k+1)
		+set1ptr_from_4ptr CURR_GREEN
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// curr_blue&(k) = curr_blue&(k+1)
		+set1ptr_from_4ptr CURR_BLUE
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
	// next k
	inz
	cpz #31
	bne -

	ldz #31
	// curr_red&(31) = tempr
	+set1ptr_from_4ptr CURR_RED
	lda tempr
	sta [ONEPTR],z
	// curr_green&(31) = tempg
	+set1ptr_from_4ptr CURR_GREEN
	lda tempg
	sta [ONEPTR],z
	// curr_blue&(31) = tempb
	+set1ptr_from_4ptr CURR_BLUE
	lda tempb
	sta [ONEPTR],z
	
	// ----------------------------

do_default:
	tya
	taz
	// tempr = default_red&(12)
	+set1ptr_from_4ptr DEFAULT_RED
	lda [ONEPTR],z
	sta tempr
	// tempg = default_green&(12)
	+set1ptr_from_4ptr DEFAULT_GREEN
	lda [ONEPTR],z
	sta tempg
	// tempb = default_blue&(12)
	+set1ptr_from_4ptr DEFAULT_BLUE
	lda [ONEPTR],z
	sta tempb

	// for k = 12 to 30
	tya
	taz
		// default_red&(k) = default_red&(k+1)
-		+set1ptr_from_4ptr DEFAULT_RED
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// default_green&(k) = default_green&(k+1)
		+set1ptr_from_4ptr DEFAULT_GREEN
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// default_blue&(k) = default_blue&(k+1)
		+set1ptr_from_4ptr DEFAULT_BLUE
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
	// next k
	inz
	cpz #31
	bne -

	ldz #31
	// default_red&(31) = tempr
	+set1ptr_from_4ptr DEFAULT_RED
	lda tempr
	sta [ONEPTR],z
	// default_green&(31) = tempg
	+set1ptr_from_4ptr DEFAULT_GREEN
	lda tempg
	sta [ONEPTR],z
	// default_blue&(31) = tempb
	+set1ptr_from_4ptr DEFAULT_BLUE
	lda tempb
	sta [ONEPTR],z

	//return
	rts

//------------------
check_box_collisions:
//------------------
//  old_sidx = sidx
//
    // prepare sidx-related pointers
    +prepare_dptr_to_array dptr_spr_ox, $0001, array_objx
    +prepare_dptr_to_array dptr_spr_oy, $0001, array_objy
    +prepare_dptr_to_array dptr_spr_fidx, $0001, array_spr_fidx

//  for sidx = 0 to spr_count - 1
    +set8 sidx, $00
.lp_sidx:
//    objx = spr_ox%(sidx)
//    objy = spr_oy%(sidx)
      +read_v16_be_from_dptr_and_inc dptr_spr_ox, objx
      +read_v16_be_from_dptr_and_inc dptr_spr_oy, objy

      // prepare sidx2-related pointers
      +prepare_dptr_to_array dptr_spr_ox2, $0001, array_objx
      +prepare_dptr_to_array dptr_spr_oy2, $0001, array_objy

//    sfidx = spr_fidx&(sidx)
      +prepare_dptr_to_array PTR1, $0001, array_spr_fidx
      ldz sidx
      +set_v8_to_val_dptr sfidx, PTR1

//    fidx = spr_frames&(sidx, sfidx)
      +prepare_dptr_to_array PTR1, $0001, array_spr_frames
      +inc_multidim_dptr_by_v8 PTR1, 101, sfidx
      ldz sidx
      +set_v8_to_val_dptr fidx, PTR1

      // prepare bb_cnt = array_bb_cnt[fidx]
      +prepare_dptr_to_array dptr_bb_cnt, $0001, array_bb_cnt
      ldz fidx
      +set_v8_to_val_dptr bb_cnt, dptr_bb_cnt

//    for sidx2 = 0 to spr_count - 1
      +set8 sidx2, $00
.lp_sidx2:
//      collision_flag = 0
        +set8 collision_flag, $00

//      if sidx <> sidx2 then begin
        +cmp8v8 sidx, sidx2
        bne .cnt_box_check

        // increment two pointers
        +inc32_dptr_twice dptr_spr_ox2
        +inc32_dptr_twice dptr_spr_oy2
        lbra .skip_box_check2

.cnt_box_check:
//        objx2 = spr_ox%(sidx2)
//        objy2 = spr_oy%(sidx2)
          +read_v16_be_from_dptr_and_inc dptr_spr_ox2, objx2
          +read_v16_be_from_dptr_and_inc dptr_spr_oy2, objy2

//        if bb_cnt&(fidx) > 0 then begin
          +cmp8 bb_cnt, $00
          lbeq .skip_box_check

//        sfidx2 = spr_fidx&(sidx2)
          +prepare_dptr_to_array PTR1, $0001, array_spr_fidx
          ldz sidx2
          +set_v8_to_val_dptr sfidx2, PTR1

//        fidx2 = spr_frames&(sidx2, sfidx2)
          +get_indexed_val8_in_multidim_dptr fidx2, array_spr_frames, 101, sidx2, sfidx2

          // prepare bb_cnt = array_bb_cnt[fidx]
          +prepare_dptr_to_array dptr_bb_cnt, $0001, array_bb_cnt
          ldz fidx2
          +set_v8_to_val_dptr bb_cnt2, dptr_bb_cnt
      
//          for k1 = 0 to bb_cnt&(fidx) - 1
            +set8 k1, $00
.lp_k1
//            box1_x1% = objx + bb_tlx&(fidx, k1)
              +get_indexed_val8_in_multidim_dptr tmp, array_bb_tlx, 101, fidx, k1
              +copy16 box1_x1, objx
              +add16v8 box1_x1, tmp

//            box1_y1% = objy + bb_tly&(fidx, k1)
              +get_indexed_val8_in_multidim_dptr tmp, array_bb_tly, 101, fidx, k1
              +copy16 box1_y1, objy
              +add16v8 box1_y1, tmp

//            box1_x2% = objx + bb_brx&(fidx, k1)
              +get_indexed_val8_in_multidim_dptr tmp, array_bb_brx, 101, fidx, k1
              +copy16 box1_x2, objx
              +add16v8 box1_x2, tmp

//            box1_y2% = objy + bb_bry&(fidx, k1)
              +get_indexed_val8_in_multidim_dptr tmp, array_bb_bry, 101, fidx, k1
              +copy16 box1_y2, objy
              +add16v8 box1_y2, tmp

//            if bb_cnt&(fidx2) > 0 then begin
              +cmp8 bb_cnt2, $00
              lbeq .skip_box_check_inner

//              for k2 = 0 to bb_cnt&(fidx2) - 1
                +set8 k2, $00
.lp_k2:
//                box2_x1% = objx2 + bb_tlx&(fidx2, k2)
                  +get_indexed_val8_in_multidim_dptr tmp, array_bb_tlx, 101, fidx2, k2
                  +copy16 box2_x1, objx2
                  +add16v8 box2_x1, tmp

//                box2_y1% = objy2 + bb_tly&(fidx2, k2)
                  +get_indexed_val8_in_multidim_dptr tmp, array_bb_tly, 101, fidx2, k2
                  +copy16 box2_y1, objy2
                  +add16v8 box2_y1, tmp

//                box2_x2% = objx2 + bb_brx&(fidx2, k2)
                  +get_indexed_val8_in_multidim_dptr tmp, array_bb_brx, 101, fidx2, k2
                  +copy16 box2_x2, objx2
                  +add16v8 box2_x2, tmp

//                box2_y2% = objy2 + bb_bry&(fidx2, k2)
                  +get_indexed_val8_in_multidim_dptr tmp, array_bb_bry, 101, fidx2, k2
                  +copy16 box2_y2, objy2
                  +add16v8 box2_y2, tmp

//                gosub check_box_collision
                  jsr check_box_collision

//              next k2
                inc k2
                +cmp8v8 k2, bb_cnt2
                lbne .lp_k2

//            bend
.skip_box_check_inner:

//          next k1
            inc k1
            +cmp8v8 k1, bb_cnt
            lbne .lp_k1

//        bend
.skip_box_check:

//        spr_collide&(sidx, sidx2) = collision_flag
          +set_indexed_val8_in_multidim_dptr_to_v8 array_spr_collide, spr_count, sidx, sidx2, collision_flag
//
//      bend
.skip_box_check2:

//    next sidx2
      inc sidx2
      +cmp8v8 sidx2, spr_count
      lbne .lp_sidx2
//      
//  next sidx
    inc sidx
    +cmp8v8 sidx, spr_count
    lbne .lp_sidx

//  sidx = old_sidx
//
//  if collision_flag = 1 then begin
//    border 7
//  bend : else begin
//    border 0
//  bend
//
//  return
    rts

!macro cmp16 .var1, .var2 {
  sec
  lda .var1
  sbc .var2

  lda .var1+1
  sbc .var2+1
}

//-----------------
check_box_collision:
//-----------------
//  if not (box2_x1% > box1_x2% or {x5F}
//          box2_x2% < box1_x1% or {x5F}
//          box2_y1% > box1_y2% or {x5F}
//          box2_y2% < box1_y1%) then {x5F}
  +cmp16 box1_x2, box2_x1
  bcc .skip
  +cmp16 box2_x2, box1_x1
  bcc .skip
  +cmp16 box1_y2, box2_y1
  bcc .skip
  +cmp16 box2_y2, box1_y1
  bcc .skip

//  begin
//    'tx = 0 : ty = 0 : a$ = "spr" + str$(sidx) + ", spr" + str$(sidx2)
//    'gosub draw_text
//
//    'ty = 1 : a$ = "fidx="+str$(fidx) + ", fidx2="+str$(fidx2)
//    'gosub draw_text
//
//    'ty = 2
//    'a$ = "(" + str$(box1_x1%) + "," + str$(box1_y1%) + ") - ("
//    'a$ = a$ + str$(box1_x2%) + "," + str$(box1_y2%) + ")"
//    'gosub draw_text
//
//    'ty = 3
//    'a$ = "(" + str$(box2_x1%) + "," + str$(box2_y1%) + ") - ("
//    'a$ = a$ + str$(box2_x2%) + "," + str$(box2_y2%) + ")"
//    'gosub draw_text
//
//    'get key a$

//    collision_flag = (2 ^ k2) or collision_flag
      +set8 tmp, $01
      +lsl8_by_v8 tmp, k2
      lda collision_flag
      ora tmp
      sta collision_flag

.skip:
//  bend

//  return
    rts


//--------
draw_frame:
//--------
//  ty = 1 : tx = 0 : tclr = 12
    +set8 ty, 1
    +set8 tx, 0
    +set8 tclr, 12

//  for yy = 1 to chr_height(fidx)
    +set8 yy, 1
----:
//    ty = ty + 1
      +inc8 ty

//    tx = 0
      +set8 tx, 0
//
//    for x = 1 to chr_width(fidx)
      ldx #$01
--:
//      value = $1002 : gosub plot_char
        +set16 value, $1002
        jsr plot_char

//      tx = tx + 1
        +inc8 tx
//
//      value = $1003
        +set16 value, $1003

//      for k = 1 to 7
        +set8 kptr, 1
-:
//        gosub plot_char
          jsr plot_char

//        tx = tx + 1
          +inc8 tx

//      next k
        +inc8 kptr
        +cmp8 kptr, 8
        bne -

//    next x
      inx
      cpx chr_width
      bcc --
      beq --

//    value = $1006 : gosub plot_char
      +set16 value, $1006
      jsr plot_char

//    for y = 1 to 7
      ldy #$01
---:
//      ty = ty + 1
        +inc8 ty

//      tx = 0
        +set8 tx, 0

//      for x = 1 to chr_width(fidx)
        ldx #$01
--:
//        value = $1004 : gosub plot_char
          +set16 value, $1004
          jsr plot_char

//        tx = tx + 1
          +inc8 tx

//        value = $1005
          +set16 value, $1005

//        for k = 1 to 7
          +set8 kptr, 1
-:
//          gosub plot_char
            jsr plot_char

//          tx = tx + 1
            +inc8 tx

//        next k
          +inc8 kptr
          +cmp8 kptr, $08
          bne -

//      next x
        inx
        cpx chr_width
        bcc --
        beq --

//      value = $1006 : gosub plot_char
        +set16 value, $1006
        jsr plot_char
//
//    next y
      iny
      cpy #$08
      bcc ---

//  next yy
    +inc8 yy
    +cmp8v8 yy, chr_height
    lbcc ----
    lbeq ----

//  ty = ty + 1
    +inc8 ty

//  tx = 0
    +set8 tx, 0

//  value = $1007
    +set16 value, $1007

    +copy8 kptr, chr_width
    +lsl8_by kptr, 3

//  for x = 1 to chr_width(fidx) * 8
    ldx #$01
-:
//    gosub plot_char
      jsr plot_char

//    tx = tx + 1
      +inc8 tx

//  next x
    inx
    cpx kptr
    bcc -
    beq -

//  return
    rts

//-----------------
draw_frame_contents:
//-----------------

//  for xx = 0 to chr_width(fidx) - 1
    +set8 xx, $00
----:
//    for yy = 0 to chr_height(fidx) - 1
      +set8 yy, $00
---: 
//      tx = xx * 8
        +copy8 tx, xx
        +lsl8_by tx, 3

//      ty = yy * 8 + 2
        +copy8 ty, yy
        +lsl8_by ty, 3
        +add8 ty, 2

//      for y = 0 to 7
        ldy #$00
--:
//        for x = 0 to 7
          ldx #$00
-:
//          tclr = peek(char_idx(fidx) * $40 + $40 * chr_height(fidx) * xx + $40 * yy + y * 8 + x)
            // outputw = char_idx * $40
            +copy16 inputw1, char_idx
            +set16 inputw2, $40
            +multiply16 inputw1, inputw2, outputw

            // inputw = $40 * chr_height * xx
            +copy8to16 inputw1, chr_height
            +multiply16 inputw1, inputw2, inputw1
            +copy8to16 inputw2, xx
            +multiply16 inputw1, inputw2, inputw1

            // outputw += intputw1
            +add16 inputw1, outputw, outputw

            // inputw1 = $40 * yy
            +copy8to16 inputw1, yy
            +set16 inputw2, $40
            +multiply16 inputw1, inputw2, inputw1

            // outputw += intputw1
            +add16 inputw1, outputw, outputw

            // outputw += y * 8
            tya
            +lsla 3
            sta inputw1
            +set8 inputw1+1, 0
            +add16 outputw, inputw1, outputw

            // outputw += x
            stx inputw1
            +set8 inputw1+1, 0
            +add16 outputw, inputw1, outputw

            // tclr = peek(outputw)
            +copy16 FOURPTR, outputw
            +set16 FOURPTR+2, $0005
            ldz #$00
            lda [FOURPTR],z
            sta tclr

//          if tclr = 0 then tclr = 12
            +cmp8 tclr, 0
            bne +
              +set8 tclr, 12
+:
//          poke $ff80000 + (ty + y) * WIDTH + (tx + x) * 2 + 1, tclr
            tya
            clc
            adc ty
            sta inputw1
            +set8 inputw1+1, $00
            +set16 inputw2, WIDTH
            +multiply16 inputw1, inputw2, outputw

            txa
            clc
            adc tx
            sta inputw1
            +lsl16 inputw1
            +add16 inputw1, outputw, CLRPTR
            +set16 CLRPTR+2, $0ff8
            +inc32 CLRPTR

            ldz #$00
            lda tclr
            sta [CLRPTR],z

//        next x
          inx
          cpx #$08
          lbne -

//      next y
        iny
        cpy #$08
        lbne --

//    next yy
      +inc8 yy
      +cmp8v8 yy, chr_height
      lbne ---

//  next xx
    +inc8 xx
    +cmp8v8 xx, chr_width
    lbne ----

//  return
    rts


//-----------------------------
prepare_screen_and_clr_pointers:
//-----------------------------
// prepare screen pointer
//      $40800 + ty * WIDTH + tx * 2
    phx
    phy

    clc
    lda tx
    rol
    sta inputw1
    lda #$00
    adc #$00
    sta inputw1+1

    lda #WIDTH
    sta tmp
    +multiply8 ty, tmp, inputw2

    +add16 inputw1, inputw2, outputw

    lda #$00
    sta inputw2
    lda #$08
    sta inputw2+1
    +add16 outputw, inputw2, PTR1

    lda #$04
    sta PTR1+2
    lda #$00
    sta PTR1+3


// prepare CLRPTR before loop starts
//     $ff80000 + ty * WIDTH + tx * 2 + 1
    lda outputw
    sta CLRPTR
    lda outputw+1
    sta CLRPTR+1
    lda #$f8
    sta CLRPTR+2
    lda #$0f
    sta CLRPTR+3

    ply
    plx
    rts


//-----------------------
preserve_data_behind_pane:
//-----------------------
//  xx% = pane_x + pane_width% - 1
    +copy8 xx, pane_width
    +dec8 xx
    +add8v8 xx, pane_x

//  yy% = pane_y + pane_height% - 1
    +copy8 yy, pane_height
    +dec8 yy
    +add8v8 yy, pane_y

//  ' preserve screen + colour data behind pane
//  ' save to $4,4000
//  loc = $44000
    +set16 FOURPTR, $4000
    +set16 FOURPTR+2, $0004

//  for ty = pane_y% to yy%
    +copy8 ty, pane_y
--:

//    for tx = pane_x% to xx%
      +copy8 tx, pane_x

      jsr prepare_screen_and_clr_pointers

-:
//      wpoke loc, wpeek($40800 + ty * WIDTH + tx * 2)
        ldz #$00
        lda [PTR1],z
        sta [FOURPTR],z
        inz
        lda [PTR1],z
        sta [FOURPTR],z

//      loc = loc + 2
        +inc32 FOURPTR
        +inc32 FOURPTR

//      wpoke loc, wpeek($ff80000 + ty * WIDTH + tx * 2)
        ldz #$00
        lda [CLRPTR],z
        sta [FOURPTR],z
        inz
        lda [CLRPTR],z
        sta [FOURPTR],z

//      loc = loc + 2
        +inc32 FOURPTR
        +inc32 FOURPTR

        +inc32 PTR1
        +inc32 PTR1

        +inc32 CLRPTR
        +inc32 CLRPTR
//    next tx
      +inc8 tx
      cmp xx
      bcc -
      beq -
//  next ty
    +inc8 ty
    cmp yy
    bcc --
    beq --

    rts


//-----------------
draw_pane_horz_lines:
//-----------------
//  for tx = pane_x% to xx%
    +copy8 tx, pane_x
-:
//    value = $100b
      +set16 value, $100b

//    ty = pane_y% : gosub plot_char
      +copy8 ty, pane_y
      jsr plot_char

//    value = $100d
      +set16 value, $100d

//    ty = yy% : gosub plot_char
      +copy8 ty, yy
      jsr plot_char

//  next tx
    +inc8 tx
    cmp xx
    bne -

  rts


//-----------------
draw_pane_vert_lines:
//-----------------
//  for ty = pane_y% to yy%
    +copy8 ty, pane_y
-:
//    value = $1009
      +set16 value, $1009

//    tx = pane_x% : gosub plot_char
      +copy8 tx, pane_x
      jsr plot_char
      
//    value = $100f
      +set16 value, $100f

//    tx = xx% : gosub plot_char
      +copy8 tx, xx
      jsr plot_char

//  next ty
    +inc8 ty
    cmp yy
    bne -

  rts


//--------------
draw_pane_corners:
//--------------
//  tx = pane_x% : ty = pane_y% : value = $1008 : gosub plot_char
    +copy8 tx, pane_x
    +copy8 ty, pane_y
    +set16 value, $1008
    jsr plot_char

//  tx = pane_x% : ty = yy%    : value = $100a : gosub plot_char
    +copy8 tx, pane_x
    +copy8 ty, yy
    +set16 value, $100a
    jsr plot_char

//  tx = xx%    : ty = pane_y% : value = $100e : gosub plot_char
    +copy8 tx, xx
    +copy8 ty, pane_y
    +set16 value, $100e
    jsr plot_char

//  tx = xx%    : ty = yy%    : value = $1010 : gosub plot_char
    +copy8 tx, xx
    +copy8 ty, yy
    +set16 value, $1010
    jsr plot_char
    rts


//------
hide_pane:
//------
//  xx% = pane_x + pane_width% - 1
    +copy8 xx, pane_width
    +dec8 xx
    +add8v8 xx, pane_x

//  yy% = pane_y + pane_height% - 1
    +copy8 yy, pane_height
    +dec8 yy
    +add8v8 yy, pane_y

//  loc = $44000
    +set16 FOURPTR, $4000
    +set16 FOURPTR+2, $0004

//  for ty = pane_y% to yy%
    +copy8 ty, pane_y
--:

//    for tx = pane_x% to xx%
      +copy8 tx, pane_x

      jsr prepare_screen_and_clr_pointers

-:
//      wpoke $40800 + ty * WIDTH + tx * 2, wpeek(loc)
        ldz #$00
        lda [FOURPTR],z
        sta [PTR1],z
        inz
        lda [FOURPTR],z
        sta [PTR1],z

//      loc = loc + 2
        +inc32 FOURPTR
        +inc32 FOURPTR

//      wpoke $ff80000 + ty * WIDTH + tx * 2, wpeek(loc)
        ldz #$00
        lda [FOURPTR],z
        sta [CLRPTR],z
        inz
        lda [FOURPTR],z
        sta [CLRPTR],z

//      loc = loc + 2
        +inc32 FOURPTR
        +inc32 FOURPTR

        +inc32 PTR1
        +inc32 PTR1

        +inc32 CLRPTR
        +inc32 CLRPTR

//    next tx
      +inc8 tx
      cmp xx
      bcc -
      beq -

//  next ty
    +inc8 ty
    cmp yy
    bcc --
    beq --

//  return
  rts


//----------------
clear_pane_insides:
//----------------
//  value = 32
    +set16 value, 32

//  for ty = pane_y% + 1 to yy% - 1
    +copy8 ty, pane_y
    +inc8 ty
--:
//    for tx = pane_x% + 1 to xx% - 1
    +copy8 tx, pane_x
    +inc8 tx
-:
//      gosub plot_char
        jsr plot_char

//    next tx
      +inc8 tx
      cmp xx
      bcc -

//  next ty
    +inc8 ty
    cmp yy
    bcc --

    rts


//------
draw_pane:
//------
    jsr preserve_data_behind_pane

    jsr draw_pane_horz_lines

    jsr draw_pane_vert_lines

    jsr draw_pane_corners

    jsr clear_pane_insides

//  return
    rts


//-------
plot_char:
//-------
    jsr prepare_screen_and_clr_pointers

//  wpoke $40800 + ty * WIDTH + tx * 2, value
    ldz #$00
    lda value
    sta [PTR1],z
    inz
    lda value+1
    sta [PTR1],z

//  wpoke $ff80000 + ty * WIDTH + tx * 2, tclr * 256
    ldz #$00
    lda #$00
    sta [CLRPTR],z
    inz
    lda tclr
    sta [CLRPTR],z
//  return
    rts

//-------
clrscreen:
//-------
//  edma OP_FILL, WIDTH * 50, 32, $40800
  lda #$00
  sta $d702
  lda #>dma_screen
  sta $d701
  lda #<dma_screen
  sta $d705

//  edma OP_FILL, WIDTH * 50, 0, $ff80000
  lda #>dma_clr
  sta $d701
  lda #<dma_clr
  sta $d705

//  ' clear screen
//  for y = 0 to 49
    ldy #$00
--:
//   for x = 0 to 79
    ldx #$00
-:
//     poke $40800 + y * WIDTH + x * 2 + 1, 0
    sty tmp
    +copy8to16 inputw1, tmp
    +set16 inputw2, WIDTH
    +multiply16 inputw1, inputw2, inputw1

    txa
    clc
    rol
    sta tmp
    +copy8to16 inputw2, tmp

    +add16 inputw1, inputw2, inputw1

    +set16 inputw2, $0800
    +add16 inputw1, inputw2, FOURPTR
    +set16 FOURPTR+2, $0004

    ldz #$01
    lda #$00
    sta [FOURPTR],z

//   next x
  inx
  cpx #80
  lbne -

//  next y
  iny
  cpy #50
  lbne --

//  return
  rts


//-------
draw_text:
//-------
// input:
//   x = string low-ptr
//   y = string high-ptr
  stx ZEROPTR
  sty ZEROPTR+1
  lda #$00
  sta ZEROPTR+2
  sta ZEROPTR+3

  // prepare pointer to string in ONEPTR
  ldz #$00
  lda [ZEROPTR],z
  sta stringlen
  inz
  lda [ZEROPTR],z
  sta ONEPTR
  inz
  lda [ZEROPTR],z
  sta ONEPTR+1
  lda #$01
  sta ONEPTR+2
  lda #$00
  sta ONEPTR+3

//   idx = 0

//   rev_flag = 0
  sta rev_flag

// prepare FOURPTR before loop starts
//     wpoke $40800 + ty * WIDTH + (tx + idx) * 2, chr
    clc
    lda tx
    rol
    sta inputw1
    lda #$00
    adc #$00
    sta inputw1+1

    lda #WIDTH
    sta tmp
    +multiply8 ty, tmp, inputw2

    +add16 inputw1, inputw2, inputw1

    lda #$00
    sta inputw2
    lda #$08
    sta inputw2+1
    +add16 inputw1, inputw2, FOURPTR

    lda #$04
    sta FOURPTR+2
    lda #$00
    sta FOURPTR+3

// prepare CLRPTR before loop starts
//     poke $ff80000 + ty * WIDTH + (tx + idx) * 2 + 1, tclr
    lda inputw1
    sta CLRPTR
    lda inputw1+1
    sta CLRPTR+1
    lda #$f8
    sta CLRPTR+2
    lda #$0f
    sta CLRPTR+3

//   for k = 1 to len(a$)
  ldz #$00
  stz kptr
//     chr = asc(mid$(a$,k,1))
-:
  ldz kptr
  lda [ONEPTR],z
  sta chr
//     if mid$(a$,k,1) = KEY_REV_ON then rev_flag = 1 : goto nxtdt
    cmp #18 // KEY_REV_ON
    bne +
      lda #$01
      sta rev_flag
      lbra ++

+:
//     if mid$(a$,k,1) = KEY_REV_OFF then rev_flag = 0 : goto nxtdt
    cmp #146 // KEY_REV_OFF
    bne +
      lda #$00
      sta rev_flag
      lbra ++
+:
// 
//     gosub petscii_to_screencode
    jsr petscii_to_screencode
// 
//     if rev_flag = 1 then chr = chr or $80
    ldx rev_flag
    beq +
      lda chr
      ora #$80
      sta chr
+:

//     wpoke $40800 + ty * WIDTH + (tx + idx) * 2, chr
    ldz #$00
    lda chr
    sta [FOURPTR],z
    inz
    lda #$00
    sta [FOURPTR],z

    inw FOURPTR
    bne +
    inw FOURPTR+2
+:
    inw FOURPTR
    bne +
    inw FOURPTR+2
+:
//     poke $ff80000 + ty * WIDTH + (tx + idx) * 2 + 1, tclr
    ldz #$01
    lda tclr
    sta [CLRPTR],z

    inw CLRPTR
    bne +
    inw CLRPTR+2
+:
    inw CLRPTR
    bne +
    inw CLRPTR+2
+:

//     idx = idx + 1
// .nxtdt
++:
//   next k
  ldz kptr
  inz
  stz kptr
  cpz stringlen
  lbne -
//   return
  rts


//-------------------
petscii_to_screencode:
//-------------------
//  if chr>=$00 and chr<=$1f then chr = chr or $80 : return
  lda chr
  cmp #$20
  bcs +
    ora #$80
    sta chr
    rts
//  if chr>=$20 and chr<=$3f then return
+:
  cmp #$40
  bcs +
    rts
//  if chr>=$40 and chr<=$5f then chr=chr and $bf : return
+:
  cmp #$60
  bcs +
    and #$bf
    sta chr
    rts
//  if chr>=$60 and chr<=$7f then chr=chr and $df : return
+:
  cmp #$80
  bcs +
    and #$df
    sta chr
    rts
//  if chr>=$80 and chr<=$9f then chr=chr or $40 : return
+:
  cmp #$a0
  bcs +
    ora #$40
    sta chr
    rts
//  if chr>=$a0 and chr<=$bf then chr=(chr and $7f) or $40 : return
+:
  cmp #$c0
  bcs +
    and #$7f
    ora #$40
    sta chr
    rts
//  if chr>=$c0 and chr<=$fe then chr=chr and $7f : return
+:
  cmp #$ff
  bcs +
    and #$7f
    sta chr

+:
  rts

//-----------
draw_objects:
//-----------
//   - word array_objx@1600
//   - word array_objy@1602
//   - byte array_chr_width@1604
//   - byte array_chr_height@1606
//   - word array_char_idx@1608
//   - word array_stage_x_offs@160a
//   - byte spr_count@160c

//  old_sidx = sidx
    // skip this, not needed

//  for sidx = 0 to spr_count% - 1
    lda #$00
    sta sidx
-:
//    gosub draw_object
    jsr prepare_vars
    jsr draw_object
//  next sidx
    inc sidx
    lda sidx
    cmp spr_count
    bne -

//  sidx = old_sidx
//  return
  rts


//----------
prepare_vars:
//----------
  +prepare_oneptr_to_word_idx sidx

  +prepvar16 array_objx, objx
  +prepvar16 array_objy, objy
  +prepvar8  array_chr_width, chr_width
  +prepvar8  array_chr_height, chr_height
  +prepvar16 array_char_idx, char_idx
  +prepvar16 array_stage_x_offs, stage_x_offs

  rts

//---------
draw_object:
//---------
// input:
//   - word objx@1600
//   - word objy@1602
//   - byte chr_width@1604
//   - byte chr_height@1605
//   - word char_idx@1606
//   - word stage_x_offs@1608

//  yy = int(objy / 8)
    //lda #$02
    //sta $d020

    clc
    lda stage_x_offs
    rol
    sta stage_x_offs
    lda stage_x_offs+1
    rol
    sta stage_x_offs+1

    +copy16 tempval, objy
    +lsr16_by tempval, 3
    lda tempval
    sta yy

//  yybot = yy + chr_height(sidx) ' - 1
    lda yy
    clc
    adc chr_height
    sta yybot

//  offsy = mod(objy, 8)
    lda objy
    and #$07
    sta offsy

//  ' clear prior position (if needbe)
//  if oldyy <> INVALID and yy <> oldyy then begin
    ldx sidx
    lda array_oldyy,x
    sta oldyy
    cmp #$80
    lbeq skip_clear_old_position

    cmp yy
    lbeq skip_clear_old_position

//    minyy = oldyy
      lda oldyy
      sta minyy

//    maxyy = oldyy + chr_height(sidx) ' - 1
      clc
      adc chr_height
      sta maxyy

//    if minyy < yy and yy < maxyy then maxyy = yy - 1
      lda minyy
      cmp yy
      bcs skip_adjust_maxyy

      lda yy
      cmp maxyy
      bcs skip_adjust_maxyy

        ldx yy
        dex
        stx maxyy

skip_adjust_maxyy:

//    if minyy < yybot and yybot < maxyy then minyy = yybot + 1
      lda minyy
      cmp yybot
      bcs skip_adjust_minyy

      lda yybot
      cmp maxyy
      bcs skip_adjust_minyy

        ldx yybot
        inx
        stx minyy
skip_adjust_minyy:

//    ' hide these rows off-screen
//    for y = minyy to maxyy
      ldy minyy
-:
      //      wpoke $40800 + y * WIDTH + stage_x_offs(sidx) * 2 + 160, 80 * 8 
        // outputw = y * WIDTH
        sty inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + $800 + 160
        lda #160
        sta inputw2
        lda #$08
        sta inputw2+1
        +add16 outputw, inputw2, outputw

        // set 4-pointer
        lda outputw
        sta FOURPTR
        lda outputw+1
        sta FOURPTR+1
        lda #$04
        sta FOURPTR+2
        lda #$00
        sta FOURPTR+3
     
        // wpoke to value 80 * 8 = 640 = $0280
        ldz #$00
        lda #$80
        sta [FOURPTR],z
        inz
        lda #$02
        sta [FOURPTR],z

      iny
      cpy maxyy
      lbcc -
      lbeq -
//    next y
//  bend
skip_clear_old_position:

//
//  vsync 250
//  border 2
//
//  ' draw chars on desired yrows, and at right objx position
//  char_idx = char_idx(sidx)

//  tmpx = chr_width(sidx) - 1
    ldx chr_width
    dex
    stx tmpx

//  tmpy = chr_height(sidx) - 1
    ldx chr_height
    dex
    stx tmpy

//  for x = 0 to tmpx
    ldx #$00
lpx:
//    for y = 0 to tmpy
      ldy #$00
lpy:
//      k = $40800 + (yy + y) * WIDTH + stage_x_offs(sidx) * 2 + 162 + x * 2

        // outputw = yy + y
        lda yy
        sta inputw1
        lda #$00
        sta inputw1+1

        sty inputw2
        lda #$00
        sta inputw2+1

        +add16 inputw1, inputw2, outputw

        // outputw = outputw * WIDTH
        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 outputw, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + $800 + 162 = 8A2
        lda #162
        sta inputw2
        lda #$08
        sta inputw2+1
        +add16 outputw, inputw2, outputw

        // outputw = outputw + x * 2
        txa
        clc
        rol
        sta inputw1
        lda #$00
        adc #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

        // set 4-pointer
        lda outputw
        sta FOURPTR
        lda outputw+1
        sta FOURPTR+1
        lda #$04
        sta FOURPTR+2
        lda #$00
        sta FOURPTR+3

//      wpoke k, char_idx
        ldz #$00
        lda char_idx
        sta [FOURPTR],z
        inz
        lda char_idx+1
        sta [FOURPTR],z

//      ' copy last y-line an extra line below (to help with y scrolling)
//      if y = tmpy then begin
        cpy tmpy
        bne skip_copy_last_line_twice
//        wpoke k + WIDTH, char_idx
          ldz #WIDTH
          lda char_idx
          sta [FOURPTR],z
          inz
          lda char_idx+1
          sta [FOURPTR],z

//      bend
skip_copy_last_line_twice:
//
//      char_idx = char_idx + 1
        clc
        lda char_idx
        adc #$01
        sta char_idx
        lda char_idx+1
        adc #$00
        sta char_idx+1

//    next y   //    for y = 0 to tmpy
      iny
      cpy tmpy
      lbcc lpy
      lbeq lpy
  
//  next x
    inx
    cpx tmpx
    lbcc lpx
    lbeq lpx

//  ' handle negative x
//  x = objx
//  if objx < 0 then x = 1024 + objx
    lda objx+1
    and #%00000011  // only need first two bits of high byte
    sta objx+1

//  k (aka tempval) = x + (offsy * 32 + 16) * 256

    lda offsy
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    ora #$10
    sta tempval+1
    lda objx
    sta tempval
    clc
    lda objx+1
    adc tempval+1
    sta tempval+1

//  ' set initial rowmask
//  tmp = $ff80000 + yy * WIDTH + stage_x_offs(sidx) * 2 + 160

        // outputw = outputw * WIDTH
        lda yy
        sta inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + 160
        lda #160
        sta inputw1
        lda #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

        // set clr-pointer
        lda outputw
        sta CLRPTR
        lda outputw+1
        sta CLRPTR+1
        lda #$f8
        sta CLRPTR+2
        lda #$0f
        sta CLRPTR+3
  
//  poke tmp, %10011000
        ldz #$00
        lda #%10011000
        sta [CLRPTR],z

//  poke tmp + 1, 255 << offsy and 255

    lda #$ff
    ldx offsy
    cpx #$00
    beq +
-   clc
    rol
    dex
    bne -
+ 
    ldz #$01
    sta [CLRPTR],z

//  ' set initial gotox char
    lda yy
    clc
    adc tmpy
    sta maxyy

//  for y = yy to yy + tmpy
    ldy yy
lpyy:
//    tmp = y * WIDTH + stage_x_offs(sidx) * 2 + 160
        // outputw = y * WIDTH
        sty inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        +add16 outputw, stage_x_offs, outputw

        // outputw = outputw + 160
        lda #160
        sta inputw1
        lda #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

//    if y <> yy then begin
      cpy yy
      beq skip_poke
//      poke $ff80000 + tmp, %10010000
        // set clr-pointer
        lda outputw
        sta CLRPTR
        lda outputw+1
        sta CLRPTR+1
  
        ldz #$00
        lda #%10010000
        sta [CLRPTR],z
        
//    bend
skip_poke:

//    wpoke $40800 + tmp, k
      clc
      lda outputw
      sta FOURPTR
      lda outputw+1
      adc #$08
      sta FOURPTR+1

      ldz #$00
      lda tempval
      sta [FOURPTR],z
      inz
      lda tempval+1
      sta [FOURPTR],z

//  next y
    iny
    cpy maxyy
    lbcc lpyy
    lbeq lpyy
    
//  ' set final yoffs
//  k (tempval) = x + ( ((8-offsy) and 7) * 32) * 256

    lda #$08
    sec
    sbc offsy
    and #$07
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    sta tempval+1
    lda objx
    sta tempval
    clc
    lda objx+1
    adc tempval+1
    sta tempval+1

      // outputw = yybot * WIDTH
      lda yybot
      sta inputw1
      lda #$00
      sta inputw1+1

      lda #WIDTH
      sta inputw2
      lda #$00
      sta inputw2+1
      +multiply16 inputw1, inputw2, outputw

      +add16 outputw, stage_x_offs, outputw

      // outputw = outputw + 160
      lda #160
      sta inputw1
      lda #$00
      sta inputw1+1

      +add16 outputw, inputw1, outputw

//  wpoke $40800 + yybot * WIDTH + stage_x_offs(sidx) * 2 + 160, k
      lda outputw
      sta FOURPTR
      clc
      lda outputw+1
      adc #$08
      sta FOURPTR+1

      ldz #$00
      lda tempval
      sta [FOURPTR],z
      inz
      lda tempval+1
      sta [FOURPTR],z

//  ' set final rowmask
//  tmp = $ff80000 + yybot * WIDTH + stage_x_offs(sidx) * 2 + 160
    lda outputw
    sta CLRPTR
    lda outputw+1
    sta CLRPTR+1

//  poke tmp, %10011000
    ldz #$00
    lda #%10011000
    sta [CLRPTR],z

//  poke tmp + 1, 255 >> (8 - offsy) and 255
    lda #$08
    sec
    sbc offsy
    tax

    lda #$ff
    cpx #$00
    beq +
-   clc
    ror
    dex
    bne -
+
    inz
    sta [CLRPTR],z

//  oldyy = yy
    lda yy
    ldx sidx
    sta array_oldyy,x
//
//  border 0
//  return

    lda #$00
    sta $d020
  rts


// VARIABLES
// ---------
yy: !byte $00
yybot: !byte $00
offsy: !byte $00
oldyy: !byte $80    // $80 = invalid value initially
minyy: !byte $00
maxyy: !byte $00
inputw1: !word $00
inputw2: !word $00
outputw: !word $00
tmpx: !byte $00
tmpy: !byte $00
tempval: !word $00
sidx: !byte $00
sidx2: !byte $00

objx: !word $00
objy: !word $00
stage_x_offs: !word $00
array_oldyy: !fill 100, $80

// draw_text
rev_flag: !byte $00
stringlen: !byte $00
chr: !byte $00
tmp: !byte $00
kptr: !byte $00

// draw_pane
xx: !byte $00
loc: !word $00

// collision stuff
collision_flag: !byte $00
objx2: !word $00
objy2: !word $00
sfidx: !byte $00
sfidx2: !byte $00
fidx: !byte $00
fidx2: !byte $00

bb_cnt: !byte $00
bb_cnt2: !byte $00

k1: !byte $00
k2: !byte $00

box1_x1: !word $00
box1_y1: !word $00
box1_x2: !word $00
box1_y2: !word $00

box2_x1: !word $00
box2_y1: !word $00
box2_x2: !word $00
box2_y2: !word $00

dptr_spr_ox: !word $00, $00
dptr_spr_oy: !word $00, $00

dptr_spr_ox2: !word $00, $00
dptr_spr_oy2: !word $00, $00

dptr_spr_fidx: !word $00, $00
dptr_spr_frames: !word $00, $00

dptr_bb_cnt: !word $00, $00

// cycle alt palette
tempr:		!byte $00
tempg:		!byte $00
tempb:		!byte $00

dma_screen:
+edma OP_FILL, WIDTH * 50, 32, $00, $0800, $04, $00
dma_clr:
+edma OP_FILL, WIDTH * 50, 0, $00, $0000, $08, $ff
