!to "asmhelper.prg", cbm

// DEFINES
// =======
ZEROPTR = $1c
ONEPTR = $29
FOURPTR = $18
CLRPTR = $20

// for megaplot (some overlap)
COLRBASE = $0000 // Fixed to Bank ff8
ROWPTR = $18
COLPTR = $1c
MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778


// BANK4 VAR INTERFACE
// ===================
DEFAULT_RED = $20
DEFAULT_GREEN = $22
DEFAULT_BLUE = $24
CURR_RED = $26
CURR_GREEN = $28
CURR_BLUE = $2a
DATA_ADDR = $2c	// src of dma
CDATA_ADDR = $2e
SCRADDR = $30	// dest of dma
CLRADDR = $32
INC_FRM = $34
STARX = $36
STARVX = $38

MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778

WIDTH = 200

// MACROS
// ======
!macro copy16 .dest, .src {
	lda .src
	sta .dest
	lda .src+1
	sta .dest+1
}

!macro set16 .dest, .val {
	lda #<.val
	sta .dest
	lda #>.val
	sta .dest+1
}

!macro lsr16 .loc {
	clc
	lda .loc+1
	ror
	sta .loc+1
	lda .loc
	ror
	sta .loc
}

!macro lsr16_by .loc, .cnt {
	ldx #.cnt
	cpx #$00
	beq +
-	+lsr16 .loc
	dex
	bne -
+ 
}

!macro copy_basic_int .bk4loc, .out {
	+set0ptr_from_4ptr .bk4loc
	ldz #$00
	lda [ZEROPTR],z
	sta .out+1
	inz
	lda [ZEROPTR],z
	sta .out
}

!macro set0ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ZEROPTR
	inz
	lda [FOURPTR],z
	sta ZEROPTR+1
	plz
}

!macro set1ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ONEPTR
	inz
	lda [FOURPTR],z
	sta ONEPTR+1
	plz
}

!macro add16 .in1, .in2, .out {
	clc
	lda .in1
	adc .in2
	sta .out
	lda .in1+1
	adc .in2+1
	sta .out+1
	clc
}

!macro subtract16 .in1, .in2, .out {
	sec
	lda .in1
	sbc .in2
	sta .out
	lda .in1+1
	sbc .in2+1
	sta .out+1
	clc
}

!macro multiply16 .in1, .in2, .out {
	phz
	ldz #$00
	ldy #$00
	ldx .in1+1
	lda .in1
	stq MULTINA

	ldx .in2+1
	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out
	sty .out+1
	plz
}

!macro multiply8 .in1, .in2, .out {
	phz
	ldz #$00
	ldy #$00
	ldx #$00
	lda .in1
	stq MULTINA

	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out+1
	sta .out
	plz
}

!macro wpoke_b4 .offs, .intvar {
	ldz#.offs
	lda .intvar
	sta [FOURPTR],z
	inz
	lda .intvar+1
	sta [FOURPTR],z
}

!macro poke_b4 .offs, .bytevar {
	ldz#.offs
	lda .bytevar
	sta [FOURPTR],z
}

!macro poke_b4_val .offs, .byte {
	ldz#.offs
	lda#.byte
	sta [FOURPTR],z
}

!macro fade_clr1_to_white_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $f0   ' (white)
	sta clr2
	lda #$f0
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_black_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $00   ' (black)
	sta clr2
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_clr2_step .bk4ptr1, .bk4ptr2, .palette_loc {
	// flip_var = curr_red&(k)
	+set1ptr_from_4ptr .bk4ptr1
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr2
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr2 = flip_var
	sta clr2+1
	lda #$00
	sta clr2
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro edma_transp .transp, .cmd, .length, .src_addr, .src_bank, .dst_addr, .dst_bank, .dst_mb {
	!byte $81	// dest addr MB selector
	!byte .dst_mb	// destination megabyte
	!byte $07	// enable transparency
	!byte $86	// set transparency
	!byte .transp	// transparency value
	!byte $00	// end of options

	!byte .cmd	// CMD = COPY + chain

	!word .length	// length
	!word .src_addr	// src addr = $54000
	!byte .src_bank	// src bank = $05
	!word .dst_addr	// dest addr = $54000
	!byte .dst_bank	// dest bank = $05
	!byte $00	// CMD msb (ignore)
	!word $0000	// modulo (ignore)
}

!macro edma .cmd, .length, .src_addr, .src_bank, .dst_addr, .dst_bank, .dst_mb {
	!byte $06	// disable transparency
	!byte $81	// dest addr MB selector
	!byte .dst_mb	// destination megabyte
	!byte $00	// end of options

	!byte .cmd	// CMD = COPY + chain

	!word .length	// length
	!word .src_addr	// src addr = $54000
	!byte .src_bank	// src bank = $05
	!word .dst_addr	// dest addr = $54000
	!byte .dst_bank	// dest bank = $05
	!byte $00	// CMD msb (ignore)
	!word $0000	// modulo (ignore)
}

// ROUTINES
// ========
* = $1600
objx: !word $00
objy: !word $00

* = $1610
  jmp draw_object     // 1600
// 	jmp fade_colours_to_white	// 7e00
// 	jmp fade_between_colours	// 7e03
// 	jmp cycle_alt_palette		// 7e06
// 	jmp draw_petscii_frame		// 7e09
// 	jmp fade_colours_to_black	// 7e0c
// 	jmp iter_starfield		// 7e0f
// 	jmp scroll_canvas_right		// 7e12
// 	jmp page_flip			// 7e15
// 	// megaplot routines
// 	// -----------------
// 	jmp init_and_plot		// 7e18
// 	jmp init			// 7e1b
// 	jmp plot			// 7e1e
// 	jmp line			// 7e21
// 	jmp set_colour			// 7e24
// 	// rotate routines
// 	// ---------------
// 	jmp iter_greet_text		// 7e27
// 	jmp page_flip_faster		// 7e2a


//---------
draw_object:
//---------
// input:
//   - word objx@1600
//   - word objy@1602
//   - X = chr_width, Y = chr_height
    stx chr_width
    sty chr_height

//  yy = int(objy / 8)
    +copy16 tempval, objy
    +lsr16_by tempval, 3
    lda tempval
    sta yy

//  yybot = yy + chr_height(fidx) ' - 1
    lda yy
    clc
    adc chr_height
    sta yybot

//  offsy = mod(objy, 8)
    lda objy
    and #$07
    sta offsy

//  ' clear prior position (if needbe)
//  if oldyy <> INVALID and yy <> oldyy then begin
    lda oldyy
    cmp #$80
    lbeq skip_clear_old_position

    cmp yy
    lbeq skip_clear_old_position

//    minyy = oldyy
      lda oldyy
      sta minyy

//    maxyy = oldyy + chr_height(fidx) ' - 1
      clc
      adc chr_height
      sta maxyy

//    if minyy < yy and yy < maxyy then maxyy = yy - 1
      lda minyy
      cmp yy
      bcs skip_adjust_maxyy

      lda yy
      cmp maxyy
      bcs skip_adjust_maxyy

        ldx yy
        dex
        stx maxyy

skip_adjust_maxyy:

//    if minyy < yybot and yybot < maxyy then minyy = yybot + 1
      lda minyy
      cmp yybot
      bcs skip_adjust_minyy

      lda yybot
      cmp maxyy
      bcs skip_adjust_minyy

        ldx yybot
        inx
        stx minyy
skip_adjust_minyy:

//    ' hide these rows off-screen
//    for y = minyy to maxyy
      ldy minyy
-:
      //      wpoke $40800 + y * WIDTH + 160, 80 * 8 
        // outputw = y * WIDTH
        sty inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        // outputw = outputw + $800 + 160
        lda #160
        sta inputw2
        lda #$08
        sta inputw2+1
        +add16 outputw, inputw2, outputw

        // set 4-pointer
        lda outputw
        sta FOURPTR
        lda outputw+1
        sta FOURPTR+1
        lda #$04
        sta FOURPTR+2
        lda #$00
        sta FOURPTR+3
     
        // wpoke to value 80 * 8 = 640 = $0280
        ldz #$00
        lda #$80
        sta [FOURPTR],z
        inz
        lda #$02
        sta [FOURPTR],z

      iny
      cpy maxyy
      bcc -
      beq -
//    next y
//  bend
skip_clear_old_position:

//
//  vsync 250
//  border 2
//
//  ' draw chars on desired yrows, and at right objx position
//  idx = char_idx(fidx)
    // hard-code to $1008 for now
    lda #$08
    sta idx
    lda #$10
    sta idx+1

//  tmpx = chr_width(fidx) - 1
    ldx chr_width
    dex
    stx tmpx

//  tmpy = chr_height(fidx) - 1
    ldx chr_height
    dex
    stx tmpy

//  for x = 0 to tmpx
    ldx #$00
lpx:
//    for y = 0 to tmpy
      ldy #$00
lpy:
//      k = $40800 + (yy + y) * WIDTH + 162 + x * 2

        // outputw = yy + y
        lda yy
        sta inputw1
        lda #$00
        sta inputw1+1

        sty inputw2
        lda #$00
        sta inputw1+2

        +add16 inputw1, inputw2, outputw

        // outputw = outputw * WIDTH
        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 outputw, inputw2, outputw

        // outputw = outputw + $800 + 162 = 8A2
        lda #162
        sta inputw2
        lda #$08
        sta inputw2+1
        +add16 outputw, inputw2, outputw

        // outputw = outputw + x * 2
        txa
        clc
        rol
        sta inputw1
        lda #$00
        adc #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

        // set 4-pointer
        lda outputw
        sta FOURPTR
        lda outputw+1
        sta FOURPTR+1
        lda #$04
        sta FOURPTR+2
        lda #$00
        sta FOURPTR+3

//      wpoke k, idx
        ldz #$00
        lda idx
        sta [FOURPTR],z
        inz
        lda idx+1
        sta [FOURPTR],z

//      ' copy last y-line an extra line below (to help with y scrolling)
//      if y = tmpy then begin
        cpy tmpy
        bne skip_copy_last_line_twice
//        wpoke k + WIDTH, idx
          ldz #WIDTH
          lda idx
          sta [FOURPTR],z
          inz
          lda idx+1
          sta [FOURPTR],z

//      bend
skip_copy_last_line_twice:
//
//      idx = idx + 1
        clc
        lda idx
        adc #$01
        sta idx
        lda idx+1
        adc #$00
        sta idx+1

//    next y   //    for y = 0 to tmpy
      iny
      cpy tmpy
      lbcc lpy
      lbeq lpy
  
//  next x
    inx
    cpx tmpx
    lbcc lpx
    lbeq lpx

//  ' handle negative x
//  x = objx
//  if objx < 0 then x = 1024 + objx
    lda objx+1
    and #%00000011  // only need first two bits of high byte
    sta objx+1

//  k (aka tempval) = x + (offsy * 32 + 16) * 256

    lda offsy
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    ora #$10
    sta tempval+1
    lda objx
    sta tempval
    clc
    lda objx+1
    adc tempval+1
    sta tempval+1

//  ' set initial rowmask
//  tmp = $ff80000 + yy * WIDTH + 160

        // outputw = outputw * WIDTH
        lda yy
        sta inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        // outputw = outputw + 160
        lda #160
        sta inputw1
        lda #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

        // set clr-pointer
        lda outputw
        sta CLRPTR
        lda outputw+1
        sta CLRPTR+1
        lda #$f8
        sta CLRPTR+2
        lda #$0f
        sta CLRPTR+3
  
//  poke tmp, %10011000
        ldz #$00
        lda #%10011000
        sta [CLRPTR],z

//  poke tmp + 1, 255 << offsy and 255

    lda #$ff
    ldx offsy
    cpx #$00
    beq +
-   clc
    rol
    dex
    bne -
+ 
    ldz #$01
    sta [CLRPTR],z

//  ' set initial gotox char
    lda yy
    clc
    adc tmpy
    sta maxyy

//  for y = yy to yy + tmpy
    ldy yy
lpyy:
//    tmp = y * WIDTH + 160
        // outputw = y * WIDTH
        sty inputw1
        lda #$00
        sta inputw1+1

        lda #WIDTH
        sta inputw2
        lda #$00
        sta inputw2+1
        +multiply16 inputw1, inputw2, outputw

        // outputw = outputw + 160
        lda #160
        sta inputw1
        lda #$00
        sta inputw1+1

        +add16 outputw, inputw1, outputw

//    if y <> yy then begin
      cpy yy
      beq skip_poke
//      poke $ff80000 + tmp, %10010000
        // set clr-pointer
        lda outputw
        sta CLRPTR
        lda outputw+1
        sta CLRPTR+1
  
        ldz #$00
        lda #%10010000
        sta [CLRPTR],z
        
//    bend
skip_poke:

//    wpoke $40800 + tmp, k
      clc
      lda outputw
      sta FOURPTR
      lda outputw+1
      adc #$08
      sta FOURPTR+1

      ldz #$00
      lda tempval
      sta [FOURPTR],z
      inz
      lda tempval+1
      sta [FOURPTR],z

//  next y
    iny
    cpy maxyy
    lbcc lpyy
    lbeq lpyy
    
//  ' set final yoffs
//  k (tempval) = x + ( ((8-offsy) and 7) * 32) * 256

    lda #$08
    sec
    sbc offsy
    and #$07
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    clc
    rol
    sta tempval+1
    lda objx
    sta tempval
    clc
    lda objx+1
    adc tempval+1
    sta tempval+1

      // outputw = yybot * WIDTH
      lda yybot
      sta inputw1
      lda #$00
      sta inputw1+1

      lda #WIDTH
      sta inputw2
      lda #$00
      sta inputw2+1
      +multiply16 inputw1, inputw2, outputw

      // outputw = outputw + 160
      lda #160
      sta inputw1
      lda #$00
      sta inputw1+1

      +add16 outputw, inputw1, outputw

//  wpoke $40800 + yybot * WIDTH + 160, k
      lda outputw
      sta FOURPTR
      clc
      lda outputw+1
      adc #$08
      sta FOURPTR+1

      ldz #$00
      lda tempval
      sta [FOURPTR],z
      inz
      lda tempval+1
      sta [FOURPTR],z

//  ' set final rowmask
//  tmp = $ff80000 + yybot * WIDTH + 160
    lda outputw
    sta CLRPTR
    lda outputw+1
    sta CLRPTR+1

//  poke tmp, %10011000
    ldz #$00
    lda #%10011000
    sta [CLRPTR],z

//  poke tmp + 1, 255 >> (8 - offsy) and 255
    lda #$08
    sec
    sbc offsy
    tax

    lda #$ff
    cpx #$00
    beq +
-   asr
    dex
    bne -
+
    inz
    sta [CLRPTR],z

//  oldyy = yy
    lda yy
    sta oldyy
//
//  border 0
//  return
  rts


// VARIABLES
// ---------
chr_width: !byte $00
chr_height: !byte $00
yy: !byte $00
yybot: !byte $00
offsy: !byte $00
oldyy: !byte $80    // $80 = invalid value initially
minyy: !byte $00
maxyy: !byte $00
inputw1: !word $00
inputw2: !word $00
outputw: !word $00
idx: !word $00
tmpx: !byte $00
tmpy: !byte $00
tempval: !word $00

