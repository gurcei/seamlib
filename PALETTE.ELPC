#output "palette"


'--------
.declares
'--------
#declare bkp_d054&, bkp_d058&, bkp_d059&, bkp_d05e&
#declare k, a$, x, y, cx, cy, cursor_clr


'-------
.defines
'-------
#define KEY_ESCAPE = chr$(27)
#define WIDTH = 200

#define OP_COPY = 0
#define OP_MIX  = 1
#define OP_SWAP = 2
#define OP_FILL = 3

#define KEY_UP = "{x91}"
#define KEY_DOWN = "{x11}"
#define KEY_LEFT = "{x9D}"
#define KEY_RIGHT = "{x1D}"



trap runstop_trapper

'----
.main
'----
  gosub init

  gosub clrscreen

  gosub draw_palette

  gosub parse_cursor

  goto cleanup
  end


'----
.init
'----
  ' CHR16 on (for 16-bit chars)
  ' FCLRHI on (enable SEAM for char numbers > $ff)

  print "{x93}";KEY_ESCAPE;"5";
  
  bkp_d054& = peek($d054)
  bkp_d058& = peek($d058)
  bkp_d059& = peek($d059)
  bkp_d05e& = peek($d05e)

  poke $d054, $05   ' set SEAM mode CHR16 + FCLRHI
  wpoke $d058, WIDTH
  poke $d05e, WIDTH / 2

  poke $d021, 14
  poke $d020, 0

  ' $1000 = solid fcm char
  for k = 0 to 63
    poke $40000 + k, $ff
  next k

  ' $1001 = box char
  for k = 0 to 63
    if int(k / 8) = 0 or int(k / 8) = 7 then poke $40040 + k, $ff:goto nxt
    if mod(k, 8) = 0 or mod(k, 8) = 7 then poke $40040 + k, $ff:goto nxt
    poke $40040 + k, $00
.nxt
  next k

  return


'---------------
.runstop_trapper
'---------------
  if er<>30 then resume  ' ignore everything except run/stop

.cleanup
  trap
  poke $d054, bkp_d054&
  poke $d058, bkp_d058&
  poke $d059, bkp_d059&
  poke $d05e, bkp_d05e&

  end


'---------
.clrscreen
'---------
  ' clear screen
  ' for y = 0 to 49
  '  for x = 0 to 79
  '    wpoke $40800 + y * WIDTH + x * 2, 32
  '    wpoke $ff80000 + y * WIDTH + x * 2, 0
  '  next x
  'next y

  edma OP_FILL, WIDTH * 50, 32, $40800
  edma OP_FILL, WIDTH * 50, 0, $ff80000

  return


'------------
.draw_palette
'------------
  ' draw x-index
  for x = 0 to 15
    if x < 10 then wpoke $40800 + x * 2 + 2, $30 + x
    if x >= 10 then wpoke $40800 + x * 2 + 2, x - 9
    wpoke $ff80000 + x * 2 + 2, 0 * 256
  next x

  ' draw y-index
  for y = 0 to 15
    if y < 10 then wpoke $40800 + (y+1) * WIDTH, $30 + y
    if y >= 10 then wpoke $40800 + (y+1) * WIDTH, y - 9
    wpoke $ff80000 + (y+1) * WIDTH, 0 * 256
  next y

  ' draw blocks for each colour
  for y = 1 to 16
    for x = 1 to 16
      wpoke $40800 + y * WIDTH + x * 2, $1000
      wpoke $ff80000 + y * WIDTH + x * 2, ((y-1) * 16 + (x - 1)) * 256
    next x
  next y
  return


'------------
.parse_cursor
'------------
  do while 1
    gosub draw_cursor
    get a$
    if a$ = KEY_RIGHT and cx < 15 then cx = cx + 1
    if a$ = KEY_LEFT and cx > 0 then cx = cx - 1
    if a$ = KEY_UP and cy > 0 then cy = cy - 1
    if a$ = KEY_DOWN and cy < 15 then cy = cy + 1
    cursor_clr = mod(cursor_clr + 1, 16)
  loop
  return


'-----------
.draw_cursor
'-----------
  for y = 0 to 15
    k = (cx + 1) * 8
    if cy <> y then k = 80 * 8
    ' prepare GOTOX char
    poke $ff80000 + (y + 1) * WIDTH + 160, %10010000  ' gotox bit + transp flag
    wpoke $40800 + (y + 1) * WIDTH + 160, k

    ' prepare cursor char
    wpoke $ff80002 + (y + 1) * WIDTH + 160, cursor_clr * 256  ' white 
    wpoke $40802 + (y + 1) * WIDTH + 160, $1001

    ' prepare GOTOX char (to off-screen)
    poke $ff80004 + (y + 1) * WIDTH + 160, %10010000  ' gotox bit + transp flag
    wpoke $40804 + (y + 1) * WIDTH + 160, 80 * 8
  next y

  return
ÿ